<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Architecte Hôtel Pro - Flexilogis 3D</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0f172a; user-select: none; }
        
        /* Canvas Container */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: linear-gradient(to bottom, #e0f2fe, #f0f9ff); }

        /* UI Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.4); }

        /* Custom UI Components */
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            letter-spacing: 0.08em;
            color: #0f172a;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .pill {
            background: #0ea5e9;
            color: #ecfeff;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 700;
        }

        .subtle-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: #94a3b8;
        }

        .soft-card {
            border: 1px dashed rgba(15, 23, 42, 0.08);
            background: rgba(248, 250, 252, 0.6);
        }

        .btn-tool { transition: all 0.2s ease; }
        .btn-tool:active { transform: scale(0.95); }
        .btn-tool.active { background-color: #3b82f6; color: white; border-color: #2563eb; }

        .color-swatch { transition: transform 0.2s; cursor: pointer; border: 2px solid transparent; }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: #3b82f6; box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6; transform: scale(1.1); }

        /* Toast Notification */
        #toast-container {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .toast {
            background: #1e293b; color: white; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); font-size: 0.9rem;
            animation: slideIn 0.3s ease-out forwards; pointer-events: auto;
            display: flex; align-items: center; gap: 8px; border-left: 4px solid #3b82f6;
        }
        .toast.success { border-left-color: #22c55e; }
        .toast.error { border-left-color: #ef4444; }
        .toast.info { border-left-color: #3b82f6; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(10px); }
        }

        /* Loader */
        #loader {
            position: fixed; inset: 0; background: #0f172a; z-index: 9999;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1);
            border-left-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Loader -->
    <div id="loader">
        <div class="spinner mb-4"></div>
        <div class="text-white font-semibold tracking-wider">CHARGEMENT FLEXILOGIS...</div>
    </div>

    <!-- 3D Container -->
    <div id="canvas-container"></div>
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <!-- Command Ribbon -->
    <div class="absolute top-4 left-1/2 -translate-x-1/2 w-[620px] z-20">
        <div class="glass-panel rounded-2xl p-3 shadow-xl">
            <div class="flex items-center justify-between gap-4">
                <div class="flex items-center gap-3">
                    <div class="bg-sky-600 text-white p-2 rounded-xl shadow-inner"><i data-lucide="sparkles" size="20"></i></div>
                    <div>
                        <div class="text-xs uppercase tracking-wider text-slate-500 font-bold">Assistant de conception</div>
                        <div class="text-lg font-extrabold text-slate-900">Flexilogis Experience</div>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <span id="modeChip" class="pill bg-sky-600/90">Mode déplacement</span>
                    <span id="selectionChip" class="pill bg-emerald-600/90">Aucune sélection</span>
                </div>
            </div>
            <div class="mt-3 grid grid-cols-3 gap-2 text-xs text-slate-500">
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="mouse-pointer-2" size="14"></i><span>Glisser pour orbiter, clic pour sélectionner</span></div>
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="scan" size="14"></i><span id="selectionSummary">Inspecteur inactif</span></div>
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="keyboard" size="14"></i><span>Raccourcis : W/E/R, Ctrl+Z/Y</span></div>
            </div>
        </div>
    </div>

    <!-- LEFT PANEL: Creation & Tools -->
    <div class="absolute top-4 left-4 w-72 flex flex-col gap-3 z-10 max-h-[95vh]">
        
        <!-- Header -->
        <div class="glass-panel p-4 rounded-xl flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 p-1.5 rounded-lg text-white"><i data-lucide="building-2" size="20"></i></div>
                <div>
                    <h1 class="font-bold text-gray-800 text-sm leading-tight">Flexilogis Studio</h1>
                    <div class="text-[10px] text-gray-500 font-mono">PROD V2.5 FIX</div>
                </div>
            </div>
            <!-- Undo/Redo Mini -->
            <div class="flex gap-1">
                <button id="undoBtn" class="p-1.5 hover:bg-gray-100 rounded text-gray-600 disabled:opacity-30" title="Annuler (Ctrl+Z)">
                    <i data-lucide="undo-2" size="16"></i>
                </button>
                <button id="redoBtn" class="p-1.5 hover:bg-gray-100 rounded text-gray-600 disabled:opacity-30" title="Rétablir (Ctrl+Y)">
                    <i data-lucide="redo-2" size="16"></i>
                </button>
            </div>
        </div>

        <!-- Floor Management -->
        <div class="glass-panel p-3 rounded-xl">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-500 uppercase">Niveau Actif</span>
                <span id="floorBadge" class="bg-blue-100 text-blue-700 text-xs px-2 py-0.5 rounded font-bold border border-blue-200">RDC</span>
            </div>
            
            <div class="flex items-center gap-2 mb-2">
                <button id="floorDown" class="w-8 h-8 flex items-center justify-center bg-white border border-gray-200 rounded hover:bg-gray-50 text-gray-600 transition">
                    <i data-lucide="chevron-down" size="18"></i>
                </button>
                <div class="flex-1 h-8 bg-white border border-gray-200 rounded flex items-center justify-center font-bold text-gray-700 shadow-inner">
                    <span id="floorNumberDisplay">0</span>
                </div>
                <button id="floorUp" class="w-8 h-8 flex items-center justify-center bg-white border border-gray-200 rounded hover:bg-gray-50 text-gray-600 transition">
                    <i data-lucide="chevron-up" size="18"></i>
                </button>
            </div>

            <div class="grid grid-cols-2 gap-2">
                <button id="addFloorBtn" class="py-1.5 bg-blue-600 text-white text-xs font-bold rounded hover:bg-blue-700 transition flex items-center justify-center gap-1">
                    <i data-lucide="plus" size="12"></i> Ajouter
                </button>
                <button id="cloneFloorBtn" class="py-1.5 bg-indigo-100 text-indigo-700 text-xs font-bold rounded hover:bg-indigo-200 transition border border-indigo-200 flex items-center justify-center gap-1">
                    <i data-lucide="copy" size="12"></i> Dupliquer
                </button>
            </div>
        </div>

        <!-- Library -->
        <div class="glass-panel p-3 rounded-xl flex-1 overflow-y-auto">
            <span class="text-xs font-bold text-gray-400 uppercase block mb-2">Bibliothèque</span>
            <div class="space-y-2">
                <button onclick="app.createBlock('room')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-blue-50 border border-gray-200 hover:border-blue-300 rounded-lg transition group text-left">
                    <div class="w-8 h-8 rounded bg-indigo-100 text-indigo-600 flex items-center justify-center"><i data-lucide="bed-double" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700 group-hover:text-blue-700">Chambre Complète</div>
                        <div class="text-[10px] text-gray-400">Avec Fenêtre & Porte</div>
                    </div>
                </button>
                
                <button onclick="app.createBlock('corridor')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-teal-50 border border-gray-200 hover:border-teal-300 rounded-lg transition group text-left">
                    <div class="w-8 h-8 rounded bg-teal-100 text-teal-600 flex items-center justify-center"><i data-lucide="arrow-up-down" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700 group-hover:text-teal-700">Couloir</div>
                        <div class="text-[10px] text-gray-400">Liaison</div>
                    </div>
                </button>

                <button onclick="app.createBlock('stairs')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-orange-50 border border-gray-200 hover:border-orange-300 rounded-lg transition group text-left">
                    <div class="w-8 h-8 rounded bg-orange-100 text-orange-600 flex items-center justify-center"><i data-lucide="move-up-right" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700 group-hover:text-orange-700">Escalier</div>
                        <div class="text-[10px] text-gray-400">Vertical</div>
                    </div>
                </button>

                <button onclick="app.createBlock('generic')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-gray-50 border border-gray-200 hover:border-gray-300 rounded-lg transition group text-left">
                    <div class="w-8 h-8 rounded bg-slate-100 text-slate-600 flex items-center justify-center"><i data-lucide="box" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700 group-hover:text-slate-700">Zone Libre</div>
                        <div class="text-[10px] text-gray-400">Custom</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Exterior Elements -->
        <div class="glass-panel p-3 rounded-xl flex-1 overflow-y-auto">
            <span class="text-xs font-bold text-gray-400 uppercase block mb-2">Zone extérieure</span>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="app.createExterior('pelouse')" class="flex items-center gap-2 p-2 bg-white border border-green-200 rounded-lg hover:border-green-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-green-100 text-green-700 flex items-center justify-center"><i data-lucide="sprout" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Pelouse</div>
                        <div class="text-[10px] text-gray-400">Surface herbeuse</div>
                    </div>
                </button>
                <button onclick="app.createExterior('arbre')" class="flex items-center gap-2 p-2 bg-white border border-emerald-200 rounded-lg hover:border-emerald-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-emerald-100 text-emerald-700 flex items-center justify-center"><i data-lucide="trees" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Arbre</div>
                        <div class="text-[10px] text-gray-400">Volume vertical</div>
                    </div>
                </button>
                <button onclick="app.createExterior('buisson')" class="flex items-center gap-2 p-2 bg-white border border-lime-200 rounded-lg hover:border-lime-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-lime-100 text-lime-700 flex items-center justify-center"><i data-lucide="leaf" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Buisson</div>
                        <div class="text-[10px] text-gray-400">Masse basse</div>
                    </div>
                </button>
                <button onclick="app.createExterior('haie')" class="flex items-center gap-2 p-2 bg-white border border-emerald-200 rounded-lg hover:border-emerald-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-emerald-50 text-emerald-700 flex items-center justify-center"><i data-lucide="wall" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Haie</div>
                        <div class="text-[10px] text-gray-400">Séparation végétale</div>
                    </div>
                </button>
                <button onclick="app.createExterior('portail')" class="flex items-center gap-2 p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-slate-100 text-slate-700 flex items-center justify-center"><i data-lucide="door-open" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Portail</div>
                        <div class="text-[10px] text-gray-400">Accès extérieur</div>
                    </div>
                </button>
                <button onclick="app.createExterior('poubelle')" class="flex items-center gap-2 p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-slate-100 text-slate-700 flex items-center justify-center"><i data-lucide="trash-2" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Poubelle</div>
                        <div class="text-[10px] text-gray-400">Gestion déchets</div>
                    </div>
                </button>
                <button onclick="app.createExterior('grillage')" class="flex items-center gap-2 p-2 bg-white border border-blue-200 rounded-lg hover:border-blue-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-blue-50 text-blue-700 flex items-center justify-center"><i data-lucide="grid" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Grillage</div>
                        <div class="text-[10px] text-gray-400">Clôture légère</div>
                    </div>
                </button>
                <button onclick="app.createExterior('parking')" class="flex items-center gap-2 p-2 bg-white border border-amber-200 rounded-lg hover:border-amber-400 transition text-left">
                    <div class="w-8 h-8 rounded bg-amber-50 text-amber-700 flex items-center justify-center"><i data-lucide="car" size="16"></i></div>
                    <div class="flex-1">
                        <div class="text-xs font-bold text-gray-700">Parking</div>
                        <div class="text-[10px] text-gray-400">Stationnement</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Statistics -->
        <div class="glass-panel p-3 rounded-xl">
            <span class="text-xs font-bold text-gray-400 uppercase block mb-2">Statistiques Projet</span>
            <div class="grid grid-cols-2 gap-2 text-center">
                <div class="bg-white/50 rounded p-1 border border-gray-100">
                    <div id="statRooms" class="text-sm font-bold text-gray-800">0</div>
                    <div class="text-[10px] text-gray-500">Chambres</div>
                </div>
                <div class="bg-white/50 rounded p-1 border border-gray-100">
                    <div id="statArea" class="text-sm font-bold text-gray-800">0 m²</div>
                    <div class="text-[10px] text-gray-500">Surface</div>
                </div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL: Properties & Settings -->
    <div class="absolute top-4 right-4 w-80 flex flex-col gap-3 z-10 max-h-[95vh] overflow-y-auto pr-1">

        <!-- View Settings -->
        <div class="glass-panel p-3 rounded-xl flex flex-col gap-3">
            <div class="flex items-center justify-between">
                <span class="panel-title text-xs font-extrabold">Vue et navigation</span>
                <span class="badge bg-sky-50 text-sky-700 border border-sky-100"><i data-lucide="compass" size="14"></i>Caméra</span>
            </div>
            <div class="flex gap-1">
            <button id="viewFloor" class="flex-1 py-2 text-xs font-bold rounded-lg transition flex items-center justify-center gap-2 btn-tool active">
                <i data-lucide="layers" size="14"></i> Étage
            </button>
            <button id="viewGlobal" class="flex-1 py-2 text-xs font-bold rounded-lg transition flex items-center justify-center gap-2 btn-tool bg-white/50 hover:bg-white">
                <i data-lucide="box-select" size="14"></i> Global
            </button>
            </div>
            <div class="grid grid-cols-2 gap-2 text-[11px] text-slate-500">
                <div class="soft-card rounded-lg p-2 flex items-center gap-2"><i data-lucide="eye" size="14"></i><span id="viewHint">Exploration étage en cours</span></div>
                <div class="soft-card rounded-lg p-2 flex items-center gap-2"><i data-lucide="ruler" size="14"></i><span>Nappes alignées sur la grille 0.5m</span></div>
            </div>
        </div>

        <!-- Tools Mode -->
        <div class="glass-panel p-3 rounded-xl">
            <div class="flex gap-1 bg-gray-100/50 p-1 rounded-lg">
                <button id="toolTranslate" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Déplacer (W)">
                    <i data-lucide="move" size="16"></i>
                </button>
                <button id="toolRotate" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Pivoter (E)">
                    <i data-lucide="rotate-cw" size="16"></i>
                </button>
                <button id="toolScale" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Redimensionner (R)">
                    <i data-lucide="maximize" size="16"></i>
                </button>
            </div>
            <div class="mt-2 grid grid-cols-3 gap-1 text-[10px] text-slate-500">
                <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="wand-2" size="12"></i><span>Aligner</span></div>
                <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="sprout" size="12"></i><span>Snapping</span></div>
                <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="shield" size="12"></i><span>Confort</span></div>
            </div>
        </div>

        <!-- Selection Properties (Conditional) -->
        <div id="propPanel" class="glass-panel p-4 rounded-xl transition-all duration-300 opacity-50 pointer-events-none scale-95 origin-top">
            <div class="flex justify-between items-start mb-3">
                <h2 id="propTitle" class="text-xs font-bold text-blue-600 uppercase tracking-wide">Propriétés</h2>
                <button id="deleteBtn" class="text-red-400 hover:text-red-600 transition" title="Supprimer"><i data-lucide="trash-2" size="16"></i></button>
            </div>

            <div class="grid grid-cols-2 gap-2 mb-4 text-[11px] text-slate-600">
                <div class="soft-card rounded-lg p-2 flex flex-col gap-1">
                    <span class="subtle-label">Cible active</span>
                    <span id="colorTargetBadge" class="badge bg-indigo-50 text-indigo-700 border border-indigo-100"><i data-lucide="paint-bucket" size="14"></i>Murs</span>
                </div>
                <div class="soft-card rounded-lg p-2 flex flex-col gap-1">
                    <span class="subtle-label">Niveau</span>
                    <span id="floorContextBadge" class="badge bg-emerald-50 text-emerald-700 border border-emerald-100"><i data-lucide="map-pin" size="14"></i>RDC</span>
                </div>
            </div>

            <!-- Name Input -->
            <div class="mb-4">
                <label class="block text-[10px] font-bold text-gray-500 mb-1">IDENTIFIANT / NOM</label>
                <div class="flex gap-1">
                    <input type="text" id="propName" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-sm focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition">
                    <button id="propNameBtn" class="px-2 bg-blue-50 text-blue-600 rounded border border-blue-100 hover:bg-blue-100"><i data-lucide="check" size="14"></i></button>
                </div>
            </div>

            <!-- Rotation Presets -->
            <div id="rotationSection" class="mb-4">
                <div class="flex items-center justify-between mb-2">
                    <span class="block text-[10px] font-bold text-gray-500">ROTATIONS GUIDÉES</span>
                    <div class="flex items-center gap-1">
                        <label class="text-[10px] text-slate-500">Axe</label>
                        <select id="rotationAxisSelect" class="text-xs border border-gray-200 rounded px-1 py-0.5 bg-white">
                            <option value="y">Y</option>
                            <option value="x">X</option>
                            <option value="z">Z</option>
                        </select>
                        <label class="text-[10px] text-slate-500">Angle</label>
                        <select id="rotationAngleSelect" class="text-xs border border-gray-200 rounded px-1 py-0.5 bg-white">
                            <option value="15">15°</option>
                            <option value="30">30°</option>
                            <option value="45" selected>45°</option>
                            <option value="90">90°</option>
                            <option value="180">180°</option>
                        </select>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-2">
                    <button id="rotateCounter" class="py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                        <i data-lucide="rotate-ccw" size="14"></i>Rotation -
                    </button>
                    <button id="rotateClockwise" class="py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                        <i data-lucide="rotate-cw" size="14"></i>Rotation +
                    </button>
                </div>
            </div>

            <!-- Color Picker (Hidden for furniture if needed) -->
            <div id="colorSection" class="mb-4">
                <div class="flex text-[10px] font-bold text-gray-500 mb-2 gap-2 bg-gray-50 p-1 rounded">
                    <button id="targetBlock" class="flex-1 py-1 rounded text-center transition bg-white shadow-sm text-gray-800">Murs</button>
                    <button id="targetLabel" class="flex-1 py-1 rounded text-center transition hover:bg-white text-gray-400">Étiquette</button>
                </div>
                <div id="colorGrid" class="grid grid-cols-6 gap-2">
                    <!-- Generated via JS -->
                </div>
            </div>

            <!-- Presets Size -->
            <div id="sizeSection" class="mb-2">
                 <label class="block text-[10px] font-bold text-gray-500 mb-1">TAILLE RAPIDE</label>
                 <div class="flex gap-1">
                     <button onclick="app.resizeSelection('S')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">S</button>
                     <button onclick="app.resizeSelection('M')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">M</button>
                     <button onclick="app.resizeSelection('L')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">L</button>
                 </div>
            </div>

            <!-- Label Controls -->
            <div id="labelSection" class="mb-4 space-y-2">
                <div class="flex items-center justify-between">
                    <span class="block text-[10px] font-bold text-gray-500">ÉTIQUETTE</span>
                    <div class="flex gap-1">
                        <button id="toggleDoorLabelBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Porte</button>
                        <button id="toggleLabelBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Afficher</button>
                        <button id="toggleAllLabelsBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Tout</button>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-600">
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                        Taille
                        <input id="labelSizeInput" type="range" min="0.5" max="3" step="0.1" class="w-full accent-blue-500">
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                        Couleur texte
                        <input id="labelTextColorInput" type="color" class="w-full h-8 border border-gray-200 rounded" value="#ffffff">
                    </label>
                </div>
                <div class="grid grid-cols-3 gap-2 text-[10px] text-gray-600">
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                        X
                        <input id="labelPosX" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                        Y
                        <input id="labelPosY" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                        Z
                        <input id="labelPosZ" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                </div>
            </div>

            <!-- Furniture Transform Controls -->
            <div id="furnitureTransformSection" class="mb-3 space-y-2 hidden">
                <label class="block text-[10px] font-bold text-gray-500">DIMENSIONS MOBILIER</label>
                <div class="grid grid-cols-3 gap-2 text-[10px] text-gray-600">
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Largeur
                        <input id="furnScaleX" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Hauteur
                        <input id="furnScaleY" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Profondeur
                        <input id="furnScaleZ" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                </div>
                <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1 text-[10px] text-gray-600">Orientation (Y°)
                    <input id="furnRotationY" type="number" step="1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                </label>
            </div>

            <!-- Furniture Manager -->
              <div id="furnitureSection" class="mb-3 space-y-2">
                  <label class="block text-[10px] font-bold text-gray-500">OBJETS DE LA CHAMBRE</label>
                  <div class="flex gap-2">
                      <select id="furnitureSelector" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500">
                          <!-- options via JS -->
                    </select>
                    <button id="addFurnitureBtn" class="px-2 bg-blue-600 text-white rounded text-xs font-bold hover:bg-blue-700">Ajouter</button>
                    <button id="removeFurnitureBtn" class="px-2 bg-red-50 text-red-600 border border-red-200 rounded text-xs font-bold hover:bg-red-100">Suppr.</button>
                  </div>
              </div>

              <div class="mb-3 space-y-2">
                  <div class="flex items-center justify-between">
                      <label class="block text-[10px] font-bold text-gray-500">CÂBLAGE DISJONCTEURS</label>
                      <span class="badge bg-amber-50 text-amber-700 border border-amber-100"><i data-lucide="zap" size="14"></i>Flux</span>
                  </div>
                  <button id="toggleCablesBtn" class="w-full py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                      <i data-lucide="eye" size="14"></i>Masquer le câblage
                  </button>
              </div>

              <div id="breakerSection" class="mb-3 space-y-2 hidden">
                  <div class="flex items-center justify-between">
                      <span class="block text-[10px] font-bold text-gray-500">BOÎTIER DISJONCTEURS</span>
                      <span class="text-[10px] text-emerald-600 font-semibold flex items-center gap-1"><i data-lucide="circuit-board" size="14"></i>Chambres alimentées</span>
                  </div>
                  <div class="bg-white border border-gray-200 rounded-lg p-2 space-y-2 text-[10px] text-gray-700">
                      <div class="flex items-center justify-between">
                          <span class="text-gray-500">Sélectionner les chambres</span>
                          <button id="breakerSelectAll" class="px-2 py-1 bg-emerald-50 text-emerald-700 border border-emerald-100 rounded hover:bg-emerald-100">Tout</button>
                      </div>
                      <div id="breakerRoomsList" class="max-h-32 overflow-y-auto space-y-1"></div>
                  </div>
              </div>

              <div class="mb-3">
                  <label class="block text-[10px] font-bold text-gray-500 mb-1">Dupliquer vers un étage</label>
                  <div class="flex gap-2 items-center">
                      <input id="duplicateFloorTarget" type="number" min="0" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500" />
                    <span class="text-[10px] text-gray-400">RDC=0</span>
                </div>
            </div>

            <button id="duplicateBtn" class="w-full mt-2 py-2 bg-yellow-50 text-yellow-700 text-xs font-bold rounded border border-yellow-200 hover:bg-yellow-100 flex items-center justify-center gap-2">
                <i data-lucide="copy" size="14"></i> Dupliquer Objet
            </button>
        </div>

        <!-- Footer Actions -->
        <div class="glass-panel p-3 rounded-xl mt-auto">
             <div class="grid grid-cols-2 gap-2">
                 <button id="saveBtn" class="py-2 bg-green-600 text-white text-xs font-bold rounded hover:bg-green-700 shadow-lg shadow-green-900/20 transition flex items-center justify-center gap-1">
                     <i data-lucide="save" size="14"></i> Sauver
                 </button>
                 <button id="loadBtn" class="py-2 bg-gray-600 text-white text-xs font-bold rounded hover:bg-gray-700 shadow-lg shadow-gray-900/20 transition flex items-center justify-center gap-1">
                     <i data-lucide="folder-open" size="14"></i> Ouvrir
                 </button>
             </div>
             <button id="resetBtn" class="w-full mt-2 text-[10px] text-gray-400 hover:text-red-500 underline decoration-dotted text-center">Réinitialiser la scène</button>
        </div>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- APP LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            gridSize: 0.5,
            floorHeight: 3.5,
            floorGap: 0.5,
            colors: [
                '#6366f1', '#3b82f6', '#0ea5e9', '#14b8a6',
                '#22c55e', '#84cc16', '#eab308', '#f97316', 
                '#ef4444', '#a855f7', '#d946ef', '#ec4899', 
                '#64748b', '#94a3b8', '#cbd5e1', '#f1f5f9', 
                '#ffffff', '#0f172a'
            ],
            defaultLabelColor: '#1e293b',
            defaultTextColor: '#ffffff',
            defaultLabelScale: 1.2,
            defaultLabelOffset: { x: 0, y: 4, z: 0 },
            roomWidth: 4,
            roomDepth: 6
        };

        // --- FACTORY A MEUBLES ---
        const FurnitureFactory = {
            bed: () => {
                const group = new THREE.Group();
                const bedGeo = new THREE.BoxGeometry(1.6, 0.5, 2);
                const bedMat = new THREE.MeshStandardMaterial({ color: '#ffffff' });
                const bed = new THREE.Mesh(bedGeo, bedMat);
                bed.position.y = 0.25;
                bed.castShadow = true; bed.receiveShadow = true;
                
                const pillowGeo = new THREE.BoxGeometry(0.6, 0.15, 0.4);
                const pMat = new THREE.MeshStandardMaterial({color: '#cbd5e1'});
                const p1 = new THREE.Mesh(pillowGeo, pMat); p1.position.set(-0.4, 0.6, -0.7);
                const p2 = new THREE.Mesh(pillowGeo, pMat); p2.position.set(0.4, 0.6, -0.7);
                
                group.add(bed, p1, p2);
                group.userData = { isFurniture: true, type: 'bed', name: 'Lit', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            shower: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 1.2), new THREE.MeshStandardMaterial({color: '#ffffff'}));
                base.position.y = 0.05;
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2.2, 1.1), new THREE.MeshStandardMaterial({color: '#0ea5e9', transparent: true, opacity: 0.3}));
                cabin.position.y = 1.15;
                group.add(base, cabin);
                group.userData = { isFurniture: true, type: 'shower', name: 'Douche', dims: {x:1.2, z:1.2}, defaultY: 0 };
                return group;
            },
            wardrobe: () => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.4, 0.6), new THREE.MeshStandardMaterial({ color: '#854d0e' }));
                mesh.position.y = 1.2;
                mesh.castShadow = true;
                mesh.userData = { isFurniture: true, type: 'wardrobe', name: 'Armoire', dims: {x:0.8, z:0.6}, defaultY: 1.2 };
                return mesh;
            },
            desk: () => {
                const group = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 1.5), new THREE.MeshStandardMaterial({color: '#475569'}));
                top.position.y = 0.8;
                group.add(top);
                group.userData = { isFurniture: true, type: 'desk', name: 'Bureau', dims: {x:0.6, z:1.5}, defaultY: 0 };
                return group;
            },
            chair: () => {
                const group = new THREE.Group();
                const seat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.4), new THREE.MeshStandardMaterial({color: '#ef4444'}));
                seat.position.y = 0.5;
                const back = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.4), new THREE.MeshStandardMaterial({color: '#ef4444'}));
                back.position.set(0.15, 0.75, 0);
                group.add(seat, back);
                group.userData = { isFurniture: true, type: 'chair', name: 'Chaise', dims: {x:0.4, z:0.4}, defaultY: 0 };
                return group;
            },
            table: () => {
                const group = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.8), new THREE.MeshStandardMaterial({color: '#cbd5e1'}));
                top.position.y = 0.8;
                const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
                const legMat = new THREE.MeshStandardMaterial({color: '#475569'});
                const positions = [
                    [-0.6, 0.4], [0.6, 0.4], [-0.6, -0.4], [0.6, -0.4]
                ];
                positions.forEach(p => {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(p[0], 0.4, p[1]);
                    group.add(leg);
                });
                group.add(top);
                group.userData = { isFurniture: true, type: 'table', name: 'Table', dims: {x:1.4, z:0.8}, defaultY: 0 };
                return group;
            },
            tv: () => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 1.2), new THREE.MeshStandardMaterial({color: '#000000', metalness: 0.8}));
                mesh.position.y = 1.5;
                mesh.userData = { isFurniture: true, type: 'tv', name: 'TV', dims: {x:0.1, z:1.2}, defaultY: 1.5 };
                return mesh;
            },
            toilet: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.5, 20), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                base.position.y = 0.25;
                const tank = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.2), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                tank.position.set(0, 0.75, -0.15);
                const seat = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.1, 20), new THREE.MeshStandardMaterial({color: '#f8fafc'}));
                seat.position.y = 0.5;
                group.add(base, tank, seat);
                group.userData = { isFurniture: true, type: 'toilet', name: 'WC', dims: {x:0.8, z:0.8}, defaultY: 0 };
                return group;
            },
            sink: () => {
                const group = new THREE.Group();
                const column = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.7, 16), new THREE.MeshStandardMaterial({color: '#94a3b8'}));
                column.position.y = 0.35;
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.4, 0.25, 20), new THREE.MeshStandardMaterial({color: '#e5e7eb'}));
                bowl.position.y = 0.75;
                const tap = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.3), new THREE.MeshStandardMaterial({color: '#1e293b'}));
                tap.position.set(0, 0.95, -0.1);
                group.add(column, bowl, tap);
                group.userData = { isFurniture: true, type: 'sink', name: 'Évier', dims: {x:0.9, z:0.9}, defaultY: 0 };
                return group;
            },
            bathtub: () => {
                const group = new THREE.Group();
                const tub = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 0.8), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                tub.position.y = 0.3;
                const water = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 0.6), new THREE.MeshStandardMaterial({color: '#bfdbfe', transparent: true, opacity: 0.6}));
                water.position.y = 0.45;
                group.add(tub, water);
                group.userData = { isFurniture: true, type: 'bathtub', name: 'Baignoire', dims: {x:1.6, z:0.8}, defaultY: 0 };
                return group;
            },
            crib: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.1, 1.2), new THREE.MeshStandardMaterial({color: '#fef08a'}));
                base.position.y = 0.2;
                const sideMat = new THREE.MeshStandardMaterial({color: '#f59e0b'});
                const railGeo = new THREE.BoxGeometry(0.05, 0.6, 1.2);
                const rail1 = new THREE.Mesh(railGeo, sideMat); rail1.position.set(-0.35, 0.55, 0);
                const rail2 = new THREE.Mesh(railGeo, sideMat); rail2.position.set(0.35, 0.55, 0);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.05), sideMat); head.position.set(0, 0.55, 0.6);
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.05), sideMat); foot.position.set(0, 0.55, -0.6);
                group.add(base, rail1, rail2, head, foot);
                group.userData = { isFurniture: true, type: 'crib', name: 'Lit bébé', dims: {x:0.7, z:1.2}, defaultY: 0 };
                return group;
            },
            singleBed: () => {
                const group = FurnitureFactory.bed();
                group.scale.set(0.7, 1, 0.75);
                group.userData = { isFurniture: true, type: 'singleBed', name: 'Lit simple', dims: {x:1.1, z:1.6}, defaultY: 0 };
                return group;
            },
            doubleBed: () => {
                const group = FurnitureFactory.bed();
                group.userData = { isFurniture: true, type: 'doubleBed', name: 'Lit double', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            bunkBed: () => {
                const group = new THREE.Group();
                const lower = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 2), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                lower.position.y = 0.25;
                const upper = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 1.6), new THREE.MeshStandardMaterial({color: '#cbd5e1'}));
                upper.position.set(0, 1.5, 0);
                const ladder = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.6, 0.4), new THREE.MeshStandardMaterial({color: '#b45309'}));
                ladder.position.set(0.9, 0.8, 0.9);
                group.add(lower, upper, ladder);
                group.userData = { isFurniture: true, type: 'bunkBed', name: 'Lit superposé', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            door: () => {
                const group = new THREE.Group();
                const h = CONFIG.floorHeight;
                // Cadre
                const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(1.2, h, 0.3), new THREE.MeshStandardMaterial({color: '#475569'}));
                doorFrame.position.y = h/2;
                // Porte
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.0, h*0.85, 0.35), new THREE.MeshStandardMaterial({color: '#854d0e'}));
                door.position.set(0, h/2, 0); 
                
                group.add(doorFrame, door);
                group.userData = { isFurniture: true, type: 'door', name: 'Porte', isWallMounted: true, defaultY: 0 };
                return group;
            },
              window: () => {
                  const group = new THREE.Group();
                  const h = CONFIG.floorHeight;
                  // Cadre
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.4, 0.3), new THREE.MeshStandardMaterial({color: '#475569'}));
                // Vitre
                const glass = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.2, 0.32), new THREE.MeshStandardMaterial({color: '#bae6fd', transparent: true, opacity: 0.5}));

                  group.add(frame, glass);
                  // Y par défaut à 1.5m du sol (centre de la fenêtre)
                  group.userData = { isFurniture: true, type: 'window', name: 'Fenêtre', isWallMounted: true, defaultY: 1.5 };
                  return group;
              },
              balcony: () => {
                  const group = new THREE.Group();
                  const platform = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1.2), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  platform.position.y = 0.1;
                  const railMat = new THREE.MeshStandardMaterial({ color: '#111827' });
                  const rail = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 0.1), railMat);
                  rail.position.set(0, 0.9, 0.55);
                  group.add(platform, rail);
                  group.userData = { isFurniture: true, type: 'balcony', name: 'Balcon', isWallMounted: true, defaultY: 0, wallOffset: 0.8, dims: {x:2, z:1.2} };
                  return group;
              },
              frenchDoor: () => {
                  const group = new THREE.Group();
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.8, 2.6, 0.25), new THREE.MeshStandardMaterial({ color: '#475569' }));
                  const glass = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.4, 0.2), new THREE.MeshStandardMaterial({ color: '#bae6fd', transparent: true, opacity: 0.5 }));
                  glass.position.z = 0.02;
                  group.add(frame, glass);
                  group.userData = { isFurniture: true, type: 'frenchDoor', name: 'Porte-fenêtre', isWallMounted: true, defaultY: 0, dims: {x:1.8, z:0.3} };
                  return group;
              },
              innerWall: () => {
                  const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, CONFIG.floorHeight, 3), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                  mesh.position.y = CONFIG.floorHeight / 2;
                  mesh.userData = { isFurniture: true, type: 'innerWall', name: 'Mur intérieur', dims: {x:0.2, z:3}, defaultY: mesh.position.y };
                  return mesh;
              },
              wcDoor: () => {
                  const group = new THREE.Group();
                  const h = CONFIG.floorHeight * 0.9;
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(0.9, h, 0.25), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                  frame.position.y = h / 2;
                  const leaf = new THREE.Mesh(new THREE.BoxGeometry(0.7, h * 0.9, 0.3), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  leaf.position.set(0, h / 2, 0);
                  group.add(frame, leaf);
                  group.userData = { isFurniture: true, type: 'wcDoor', name: 'Porte WC', isWallMounted: true, defaultY: 0, dims: {x:0.9, z:0.3} };
                  return group;
              },
              mirror: () => {
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.08), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const glass = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.4, 0.04), new THREE.MeshStandardMaterial({ color: '#e2e8f0', metalness: 0.8, roughness: 0.1, envMapIntensity: 0.9 }));
                  glass.position.z = 0.03;
                  const group = new THREE.Group();
                  group.add(frame, glass);
                  group.userData = { isFurniture: true, type: 'mirror', name: 'Miroir', isWallMounted: true, defaultY: 1.2, dims: {x:1.2, z:0.1} };
                  return group;
              },
              wallLamp: () => {
                  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.2, 12), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const shade = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16, 0, Math.PI), new THREE.MeshStandardMaterial({ color: '#fde68a', emissive: '#fbbf24', emissiveIntensity: 0.8 }));
                  shade.position.y = 0.25;
                  const group = new THREE.Group();
                  group.add(base, shade);
                  group.userData = { isFurniture: true, type: 'wallLamp', name: 'Lampe murale', isWallMounted: true, defaultY: 1.6, dims: {x:0.3, z:0.3} };
                  return group;
              },
              wallNeon: () => {
                  const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.6, 12), new THREE.MeshStandardMaterial({ color: '#a5f3fc', emissive: '#22d3ee', emissiveIntensity: 1.1 }));
                  tube.rotation.z = Math.PI / 2;
                  const mount = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.12, 0.18), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const group = new THREE.Group();
                  group.add(mount, tube);
                  group.userData = { isFurniture: true, type: 'wallNeon', name: 'Néon mural', isWallMounted: true, defaultY: 1.8, dims: {x:1.8, z:0.2} };
                  return group;
              },
              heater: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.25), new THREE.MeshStandardMaterial({ color: '#e5e7eb' }));
                  body.position.y = 0.35;
                  const grille = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 0.05), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  grille.position.set(0, 0.65, 0.13);
                  const group = new THREE.Group();
                  group.add(body, grille);
                  group.userData = { isFurniture: true, type: 'heater', name: 'Chauffage', isWallMounted: true, defaultY: 0.35, dims: {x:1.2, z:0.25} };
                  return group;
              },
              breakerBox: () => {
                  const box = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.3), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const door = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.95, 0.05), new THREE.MeshStandardMaterial({ color: '#1f2937', opacity: 0.7, transparent: true }));
                  door.position.z = 0.15;
                  const switches = new THREE.Group();
                  const colors = ['#22c55e', '#f97316', '#38bdf8', '#eab308'];
                  colors.forEach((c, i) => {
                      const sw = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.12), new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 0.3 }));
                      sw.position.set(-0.3 + i * 0.2, 0.15, 0.16);
                      switches.add(sw);
                  });
                  const group = new THREE.Group();
                  group.add(box, door, switches);
                  group.userData = { isFurniture: true, type: 'breakerBox', name: 'Boîtier disjoncteurs', isWallMounted: true, defaultY: 1.3, dims: {x:0.8, z:0.3}, feeds: [], isBreaker: true };
                  return group;
              }
          };

        const ExteriorFactory = {
            pelouse: () => {
                const geo = new THREE.BoxGeometry(6, 0.05, 6);
                const mat = new THREE.MeshStandardMaterial({ color: '#22c55e', roughness: 0.8 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                mesh.userData = { type: 'Exterieur', element: 'pelouse', name: 'Pelouse' };
                return mesh;
            },
            arbre: () => {
                const group = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 2, 8), new THREE.MeshStandardMaterial({ color: '#92400e' }));
                trunk.position.y = 1;
                const foliage = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2.4, 8), new THREE.MeshStandardMaterial({ color: '#166534' }));
                foliage.position.y = 2.8;
                group.add(trunk, foliage);
                group.userData = { type: 'Exterieur', element: 'arbre', name: 'Arbre' };
                return group;
            },
            buisson: () => {
                const geo = new THREE.SphereGeometry(1.2, 12, 12);
                const mat = new THREE.MeshStandardMaterial({ color: '#16a34a' });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 1.1;
                mesh.userData = { type: 'Exterieur', element: 'buisson', name: 'Buisson' };
                return mesh;
            },
            haie: () => {
                const geo = new THREE.BoxGeometry(4, 1.2, 0.6);
                const mat = new THREE.MeshStandardMaterial({ color: '#15803d' });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.6;
                mesh.userData = { type: 'Exterieur', element: 'haie', name: 'Haie' };
                return mesh;
            },
            portail: () => {
                const group = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 0.2), new THREE.MeshStandardMaterial({ color: '#475569' }));
                frame.position.y = 1;
                const door = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.6, 0.1), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                door.position.y = 1;
                group.add(frame, door);
                group.userData = { type: 'Exterieur', element: 'portail', name: 'Portail' };
                return group;
            },
            poubelle: () => {
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.2, 10), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                body.position.y = 0.6;
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.55, 0.1, 10), new THREE.MeshStandardMaterial({ color: '#1e293b' }));
                lid.position.y = 1.2;
                const group = new THREE.Group(); group.add(body, lid);
                group.userData = { type: 'Exterieur', element: 'poubelle', name: 'Poubelle' };
                return group;
            },
            grillage: () => {
                const posts = new THREE.Group();
                for(let i = 0; i < 5; i++) {
                    const post = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.4, 0.1), new THREE.MeshStandardMaterial({ color: '#475569' }));
                    post.position.set(-2 + i, 0.7, 0);
                    posts.add(post);
                }
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 0.05), new THREE.MeshStandardMaterial({ color: '#cbd5e1', transparent: true, opacity: 0.5 }));
                mesh.position.y = 0.9;
                const group = new THREE.Group(); group.add(posts, mesh);
                group.userData = { type: 'Exterieur', element: 'grillage', name: 'Grillage' };
                return group;
            },
            parking: () => {
                const base = new THREE.Mesh(new THREE.BoxGeometry(6, 0.05, 4), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                base.receiveShadow = true;
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 3.6), new THREE.MeshStandardMaterial({ color: '#eab308' }));
                line.position.set(0, 0.04, 0);
                const group = new THREE.Group();
                group.add(base, line);
                group.userData = { type: 'Exterieur', element: 'parking', name: 'Parking' };
                return group;
            }
        };

        // --- STATE MANAGEMENT ---
        class StateManager {
            constructor(app) {
                this.app = app;
                this.history = [];
                this.redoStack = [];
                this.maxHistory = 30;
                this.isLocked = false;
            }
            snapshot() {
                if (this.isLocked) return;
                const state = this.app.serializeScene();
                if (this.history.length > 0 && JSON.stringify(this.history[this.history.length - 1]) === JSON.stringify(state)) return;
                this.history.push(state);
                if (this.history.length > this.maxHistory) this.history.shift();
                this.redoStack = []; 
                this.updateUI();
            }
            undo() {
                if (this.history.length === 0) return;
                const current = this.app.serializeScene();
                this.redoStack.push(current);
                const previous = this.history.pop();
                this.isLocked = true; this.app.loadScene(previous); this.isLocked = false;
                this.app.showToast('Annulé', 'info'); this.updateUI();
            }
            redo() {
                if (this.redoStack.length === 0) return;
                const next = this.redoStack.pop();
                this.history.push(this.app.serializeScene()); 
                this.isLocked = true; this.app.loadScene(next); this.isLocked = false;
                this.app.showToast('Rétabli', 'info'); this.updateUI();
            }
            updateUI() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                if(undoBtn) undoBtn.disabled = this.history.length === 0;
                if(redoBtn) redoBtn.disabled = this.redoStack.length === 0;
            }
        }

        // --- MAIN APPLICATION ---
        class HotelArchitect {
            constructor() {
                  this.scene = null; this.camera = null; this.renderer = null;
                  this.orbit = null; this.control = null; this.raycaster = new THREE.Raycaster(); this.pointer = new THREE.Vector2();
                  this.floors = { current: 0, max: 0 }; this.roomCounter = 1;
                  this.selectedObject = null; this.isGlobalView = false; this.colorTarget = 'block'; this.labelsVisible = true;
                  this.cablesVisible = true; this.cableMaterials = [];
                  this.breakerCableGroup = null;
                  this.furnitureChoices = [
                      { value: 'crib', label: 'Lit bébé' },
                      { value: 'singleBed', label: 'Lit simple (1 personne)' },
                      { value: 'doubleBed', label: 'Lit double (2 personnes)' },
                      { value: 'bunkBed', label: 'Lit superposé (mixte)' },
                      { value: 'desk', label: 'Bureau' },
                      { value: 'chair', label: 'Chaise' },
                      { value: 'table', label: 'Table' },
                      { value: 'shower', label: 'Douche' },
                      { value: 'bathtub', label: 'Baignoire' },
                      { value: 'wardrobe', label: 'Armoire' },
                      { value: 'window', label: 'Fenêtre' },
                      { value: 'door', label: 'Porte' },
                      { value: 'toilet', label: 'WC' },
                      { value: 'sink', label: 'Évier' },
                      { value: 'balcony', label: 'Balcon' },
                      { value: 'frenchDoor', label: 'Porte-fenêtre' },
                      { value: 'innerWall', label: 'Mur intérieur' },
                      { value: 'wcDoor', label: 'Porte WC' },
                      { value: 'mirror', label: 'Miroir' },
                      { value: 'wallLamp', label: 'Lampe murale' },
                      { value: 'wallNeon', label: 'Néon mural' },
                      { value: 'heater', label: 'Chauffage' },
                      { value: 'breakerBox', label: 'Boîtier disjoncteurs' }
                  ];
                this.stateManager = new StateManager(this); this.gridHelper = null;
                this.init();
            }

              getFloorY(floorIndex) {
                  return floorIndex * (CONFIG.floorHeight + CONFIG.floorGap);
              }

              makeRoomId() {
                  return 'room-' + Math.random().toString(36).slice(2, 7) + Date.now().toString(36);
              }

              ensureRoomId(room, force = false) {
                  if(!room || room.userData?.type !== 'Chambre') return;
                  if(force || !room.userData.roomId) room.userData.roomId = this.makeRoomId();
              }

              listRooms() {
                  const rooms = [];
                  this.scene.traverse(o => { if(o.userData?.type === 'Chambre') rooms.push(o); });
                  return rooms;
              }

              getRoomById(id) {
                  if(!id) return null;
                  return this.listRooms().find(r => r.userData?.roomId === id) || null;
              }

              init() {
                  this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color('#e0f2fe');
                this.scene.fog = new THREE.FogExp2(0xe0f2fe, 0.008);
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(30, 40, 40); this.camera.lookAt(0, 0, 0);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 1.5);
                sun.position.set(50, 80, 30); sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
                const d = 60; sun.shadow.camera.left = -d; sun.shadow.camera.right = d; sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
                sun.shadow.bias = -0.0005; this.scene.add(sun);

                this.gridHelper = new THREE.GridHelper(100, 200, 0x94a3b8, 0xcbd5e1);
                this.gridHelper.position.y = this.getFloorY(this.floors.current);
                this.scene.add(this.gridHelper);
                const planeGeo = new THREE.PlaneGeometry(200, 200);
                  const planeMat = new THREE.ShadowMaterial({ opacity: 0.05, color: 0x000000 });
                  const ground = new THREE.Mesh(planeGeo, planeMat);
                  ground.rotation.x = -Math.PI / 2; ground.name = "Ground"; ground.receiveShadow = true; this.scene.add(ground);

                  this.breakerCableGroup = new THREE.Group();
                  this.breakerCableGroup.name = 'BreakerCables';
                  this.breakerCableGroup.visible = this.cablesVisible;
                  this.scene.add(this.breakerCableGroup);

                  this.orbit = new OrbitControls(this.camera, this.renderer.domElement);
                  this.orbit.enableDamping = true; this.orbit.dampingFactor = 0.05; this.orbit.maxPolarAngle = Math.PI / 2 - 0.05;

                this.control = new TransformControls(this.camera, this.renderer.domElement);
                this.control.addEventListener('dragging-changed', (e) => { this.orbit.enabled = !e.value; });
                this.control.addEventListener('mouseUp', () => { this.stateManager.snapshot(); this.updateStats(); });
                this.control.addEventListener('change', () => { if (this.control.object) this.snapObject(this.control.object); });
                this.scene.add(this.control);

                window.addEventListener('resize', () => this.onResize());
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                this.renderer.domElement.addEventListener('pointerdown', (e) => this.onPointerDown(e));
                
                  this.bindUI(); this.initColorPalette();
                  this.renderer.setAnimationLoop(() => this.animate());
                  lucide.createIcons();
                  this.updateCableToggleButton();
                  document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').remove(), 500);

                this.createBlock('room');
                this.updateUI();
                this.stateManager.snapshot(); this.updateStats();
            }

            bindUI() {
                document.getElementById('toolTranslate').onclick = () => this.setMode('translate');
                document.getElementById('toolRotate').onclick = () => this.setMode('rotate');
                document.getElementById('toolScale').onclick = () => this.setMode('scale');
                document.getElementById('floorUp').onclick = () => this.changeFloor(1);
                document.getElementById('floorDown').onclick = () => this.changeFloor(-1);
                document.getElementById('addFloorBtn').onclick = () => this.addFloor();
                document.getElementById('cloneFloorBtn').onclick = () => this.cloneCurrentFloor();
                document.getElementById('viewFloor').onclick = () => this.setGlobalView(false);
                document.getElementById('viewGlobal').onclick = () => this.setGlobalView(true);
                document.getElementById('deleteBtn').onclick = () => this.deleteSelection();
                document.getElementById('duplicateBtn').onclick = () => this.duplicateSelection();
                document.getElementById('propNameBtn').onclick = () => this.updateObjectName();
                document.getElementById('propName').addEventListener('keypress', (e) => { if(e.key === 'Enter') this.updateObjectName() });
                document.getElementById('targetBlock').onclick = (e) => this.setColorTarget('block', e.target);
                document.getElementById('targetLabel').onclick = (e) => this.setColorTarget('label', e.target);
                document.getElementById('saveBtn').onclick = () => this.saveToFile();
                document.getElementById('loadBtn').onclick = () => document.getElementById('fileInput').click();
                document.getElementById('fileInput').onchange = (e) => this.loadFile(e);
                document.getElementById('resetBtn').onclick = () => this.resetScene();
                document.getElementById('undoBtn').onclick = () => this.stateManager.undo();
                document.getElementById('redoBtn').onclick = () => this.stateManager.redo();
                document.getElementById('rotateClockwise').onclick = () => this.applyPresetRotation('cw');
                document.getElementById('rotateCounter').onclick = () => this.applyPresetRotation('ccw');
                document.getElementById('labelSizeInput').oninput = (e) => this.updateLabelScale(parseFloat(e.target.value));
                document.getElementById('labelTextColorInput').oninput = (e) => this.updateLabelTextColor(e.target.value);
                ['X','Y','Z'].forEach(axis => {
                    document.getElementById('labelPos'+axis).onchange = (e) => this.updateLabelOffset(axis.toLowerCase(), parseFloat(e.target.value));
                });
                  document.getElementById('toggleDoorLabelBtn').onclick = () => this.toggleDoorLabel();
                  document.getElementById('toggleLabelBtn').onclick = () => this.toggleSelectedLabel();
                  document.getElementById('toggleAllLabelsBtn').onclick = () => this.toggleAllLabels();
                  this.populateFurnitureSelector();
                  document.getElementById('addFurnitureBtn').onclick = () => this.addFurnitureFromMenu();
                  document.getElementById('removeFurnitureBtn').onclick = () => this.removeFurnitureFromMenu();
                  document.getElementById('toggleCablesBtn').onclick = () => this.toggleBreakerCables();
                  document.getElementById('breakerSelectAll').onclick = () => this.selectAllBreakerRooms();
                  document.getElementById('breakerRoomsList').addEventListener('change', (e) => {
                      if(e.target?.dataset?.roomId) this.setBreakerFeed(this.selectedObject, e.target.dataset.roomId, e.target.checked);
                  });
                  ['X','Y','Z'].forEach(axis => {
                      document.getElementById('furnScale'+axis).onchange = (e) => this.updateFurnitureScale(axis.toLowerCase(), parseFloat(e.target.value));
                  });
                  document.getElementById('furnRotationY').onchange = (e) => this.updateFurnitureRotation(parseFloat(e.target.value));
                this.setColorTarget('block');
                this.updateSelectionChips();
            }
            
            initColorPalette() {
                const container = document.getElementById('colorGrid');
                CONFIG.colors.forEach(color => {
                    const btn = document.createElement('div');
                    btn.className = 'color-swatch w-6 h-6 rounded-full shadow-sm';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => this.applyColor(color);
                    container.appendChild(btn);
                });
            }

            populateFurnitureSelector() {
                const select = document.getElementById('furnitureSelector');
                select.innerHTML = '';
                this.furnitureChoices.forEach(opt => {
                    const o = document.createElement('option');
                    o.value = opt.value; o.textContent = opt.label; select.appendChild(o);
                });
            }

            createBlock(type, furnitureList = null, floorOverride = null) {
                let mesh;
                const targetFloor = floorOverride ?? this.floors.current;
                const yPos = this.getFloorY(targetFloor);
                const randX = Math.round((Math.random() * 4 - 2)) * 1;
                const randZ = Math.round((Math.random() * 4 - 2)) * 1;

                if (type === 'room') {
                    mesh = new THREE.Group();
                    const w = CONFIG.roomWidth, h = CONFIG.floorHeight, d = CONFIG.roomDepth;

                    // --- STRUCTURE ---
                    const shellGroup = new THREE.Group();
                    shellGroup.name = "RoomShell";
                    const matWall = new THREE.MeshStandardMaterial({ color: '#6366f1', roughness: 0.4 });
                    const matFloor = new THREE.MeshStandardMaterial({ color: '#e2e8f0', roughness: 0.8 });

                    // Sol
                    const floor = new THREE.Mesh(new THREE.BoxGeometry(w, 0.2, d), matFloor);
                    floor.position.y = 0.1; floor.receiveShadow = true; floor.userData = { isFloor: true }; shellGroup.add(floor);
                    
                    // Murs Pleins (4 Côtés)
                    const back = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.2), matWall.clone()); back.position.set(0, h/2, -d/2+0.1); back.userData = { isWall: true }; shellGroup.add(back);
                    const front = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.2), matWall.clone()); front.position.set(0, h/2, d/2-0.1); front.userData = { isWall: true }; shellGroup.add(front);
                    const left = new THREE.Mesh(new THREE.BoxGeometry(0.2, h, d), matWall.clone()); left.position.set(-w/2+0.1, h/2, 0); left.userData = { isWall: true }; shellGroup.add(left);
                    const right = new THREE.Mesh(new THREE.BoxGeometry(0.2, h, d), matWall.clone()); right.position.set(w/2-0.1, h/2, 0); right.userData = { isWall: true }; shellGroup.add(right);
                    
                    mesh.add(shellGroup);

                    // --- MOBILIER ---
                    const furnitureGroup = new THREE.Group();
                    furnitureGroup.name = "Furniture";
                    
                      if (furnitureList) {
                          furnitureList.forEach(item => {
                              const fMesh = FurnitureFactory[item.type]();
                              fMesh.position.fromArray(item.pos);
                              fMesh.rotation.fromArray(item.rot);
                              if(item.userData) fMesh.userData = {...fMesh.userData, ...item.userData};
                              furnitureGroup.add(fMesh);
                          });
                      } else {
                        // Layout Par défaut
                        const bed = FurnitureFactory.bed(); bed.position.set(0, 0, -1.5); furnitureGroup.add(bed);
                        const shower = FurnitureFactory.shower(); shower.position.set(-1.3, 0, -2.3); furnitureGroup.add(shower);
                        const desk = FurnitureFactory.desk(); desk.position.set(1.6, 0, 0.5); furnitureGroup.add(desk);
                        const wardrobe = FurnitureFactory.wardrobe(); wardrobe.position.set(1.5, 1.2, -2.5); furnitureGroup.add(wardrobe); // ward has defaultY
                        const chair = FurnitureFactory.chair(); chair.position.set(1.0, 0, 0.5); furnitureGroup.add(chair);
                        const tv = FurnitureFactory.tv(); tv.position.set(-1.8, 1.5, 0); furnitureGroup.add(tv);
                        
                        // Porte & Fenêtre par défaut
                        const door = FurnitureFactory.door(); 
                        door.position.set(-0.5, 0, d/2 - 0.1); 
                        furnitureGroup.add(door);

                        const win = FurnitureFactory.window();
                        win.position.set(1.0, win.userData.defaultY, -d/2 + 0.1); // FIX Y
                        furnitureGroup.add(win);
                    }
                    mesh.add(furnitureGroup);

                    const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshBasicMaterial({visible: false}));
                    hitBox.position.y = h/2; hitBox.name = "StructureHitbox"; 
                    mesh.add(hitBox);

                    mesh.userData = {
                        type: 'Chambre',
                        name: `Chambre ${this.roomCounter}`,
                        labelText: this.roomCounter.toString(),
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                          labelScale: CONFIG.defaultLabelScale,
                          labelOffset: {...CONFIG.defaultLabelOffset},
                          labelVisible: true,
                          doorLabelVisible: true,
                          roomId: this.makeRoomId(),
                          wallColor: '#6366f1'
                      };
                    this.roomCounter++;
                }
                else if (type === 'corridor') {
                    const geo = new THREE.BoxGeometry(10, CONFIG.floorHeight, 2);
                    const mat = new THREE.MeshStandardMaterial({ color: '#14b8a6' });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = CONFIG.floorHeight / 2;
                    mesh.userData = {
                        type: 'Couloir',
                        name: 'Couloir',
                        labelText: '',
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                        labelScale: CONFIG.defaultLabelScale,
                        labelOffset: {...CONFIG.defaultLabelOffset},
                        labelVisible: true,
                        doorLabelVisible: true
                    };
                } else if (type === 'generic') {
                    const geo = new THREE.BoxGeometry(4, CONFIG.floorHeight, 4);
                    const mat = new THREE.MeshStandardMaterial({ color: '#64748b' });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = CONFIG.floorHeight / 2;
                    mesh.userData = {
                        type: 'Zone',
                        name: 'Zone',
                        labelText: 'Zone',
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                        labelScale: CONFIG.defaultLabelScale,
                        labelOffset: {...CONFIG.defaultLabelOffset},
                        labelVisible: true,
                        doorLabelVisible: true
                    };
                } else if (type === 'stairs') {
                    mesh = new THREE.Group();
                    const steps = 8; const stepH = CONFIG.floorHeight/steps; const stepD = 4/steps;
                    for(let i=0; i<steps; i++) {
                        const s = new THREE.Mesh(new THREE.BoxGeometry(2, stepH, stepD), new THREE.MeshStandardMaterial({color: '#f97316'}));
                        s.position.set(0, (i*stepH)+(stepH/2), (i*stepD)-2); s.castShadow=true; mesh.add(s);
                    }
                    const hit = new THREE.Mesh(new THREE.BoxGeometry(2, CONFIG.floorHeight, 4), new THREE.MeshBasicMaterial({visible:false}));
                    hit.position.y = CONFIG.floorHeight/2; mesh.add(hit);
                    mesh.userData = { type: 'Escalier', name: 'Escalier' };
                }

                if (mesh) {
                    mesh.position.set(randX, yPos, randZ);
                    mesh.userData.floor = targetFloor;
                    mesh.userData.labelColor = CONFIG.defaultLabelColor;
                    mesh.userData.textColor = CONFIG.defaultTextColor;
                    
                    mesh.traverse(c => { if(c.isMesh && c.visible) { c.castShadow=true; c.receiveShadow=true; } });
                    if (mesh.userData.labelText) this.addLabel(mesh, mesh.userData.labelText);
                    else this.refreshDoorLabels(mesh);
                    if (mesh.userData.type === 'Chambre') this.setRoomWallColor(mesh, mesh.userData.wallColor || '#6366f1');

                    this.scene.add(mesh);
                    this.selectObject(mesh);
                    this.stateManager.snapshot(); this.updateStats(); this.showToast(`${mesh.userData.name} créé`, 'success');
                }
                return mesh;
            }

            createExterior(type, floorOverride = 0) {
                const factory = ExteriorFactory[type];
                if(!factory) { this.showToast('Élément extérieur inconnu', 'error'); return null; }
                const element = factory();
                const randX = Math.round((Math.random() * 8 - 4));
                const randZ = Math.round((Math.random() * 8 - 4));
                const targetFloor = floorOverride ?? 0;
                element.position.set(randX, this.getFloorY(targetFloor), randZ);
                element.userData.floor = targetFloor;
                element.userData.labelColor = CONFIG.defaultLabelColor;
                element.userData.textColor = CONFIG.defaultTextColor;
                element.userData.labelScale = CONFIG.defaultLabelScale;
                element.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                element.userData.labelVisible = false;
                element.userData.isExterior = true;
                this.scene.add(element);
                if(targetFloor > this.floors.max) { this.floors.max = targetFloor; this.updateUI(); }
                this.updateFloorVisibility();
                this.selectObject(element);
                this.stateManager.snapshot(); this.updateStats();
                this.showToast(`${element.userData.name} ajoutée`, 'success');
                return element;
            }

            addLabel(parent, text) {
                this.ensureLabelDefaults(parent);
                const old = parent.getObjectByName('Label');
                if(old) parent.remove(old);
                if(!text) return;
                const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = parent.userData.labelColor || CONFIG.defaultLabelColor;
                ctx.beginPath(); ctx.roundRect(20, 20, 472, 216, 40); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 10; ctx.stroke();
                ctx.fillStyle = parent.userData.textColor || CONFIG.defaultTextColor;
                ctx.font = 'bold 120px Inter, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 256, 128);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false }));
                sprite.name = 'Label';
                const scale = parent.userData.labelScale || CONFIG.defaultLabelScale;
                sprite.scale.set(2 * scale, 1 * scale, 1);
                const offset = parent.userData.labelOffset || CONFIG.defaultLabelOffset;
                sprite.position.set(offset.x, offset.y, offset.z);
                sprite.visible = this.labelsVisible && parent.userData.labelVisible !== false;
                sprite.userData = { isLabel: true };
                parent.add(sprite);

                this.refreshDoorLabels(parent);
            }

            ensureLabelDefaults(obj) {
                if(!obj.userData.labelColor) obj.userData.labelColor = CONFIG.defaultLabelColor;
                if(!obj.userData.textColor) obj.userData.textColor = CONFIG.defaultTextColor;
                if(!obj.userData.labelScale) obj.userData.labelScale = CONFIG.defaultLabelScale;
                if(!obj.userData.labelOffset) obj.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                if(obj.userData.labelVisible === undefined) obj.userData.labelVisible = true;
                if(obj.userData.doorLabelVisible === undefined) obj.userData.doorLabelVisible = true;
            }

            supportsDoorBadge(obj) {
                if(!obj || obj.userData?.isFurniture) return false;
                const t = obj.userData.type;
                return ['Chambre', 'Zone', 'Generic', 'Couloir'].includes(t);
            }

            getDoorLabelText(obj) {
                if(!obj || obj.userData?.isFurniture) return '';
                if(obj.userData.type === 'Chambre') return obj.userData.labelText || obj.userData.name || '';
                if(obj.userData.type === 'Zone' || obj.userData.type === 'Generic' || obj.userData.type === 'Couloir') {
                    return obj.userData.name || obj.userData.labelText || '';
                }
                return '';
            }

            clearDoorBadges(obj) {
                if(!obj) return;
                const toRemove = [];
                obj.traverse(child => { if(child.name === 'DoorBadge') toRemove.push(child); });
                toRemove.forEach(c => c.parent?.remove(c));
            }

            createDoorBadge(text) {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#111827';
                ctx.beginPath(); ctx.roundRect(16, 16, 224, 96, 20); ctx.fill();
                ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 6; ctx.stroke();
                ctx.fillStyle = '#f8fafc';
                ctx.font = text.length > 7 ? 'bold 56px Inter, Arial' : 'bold 72px Inter, Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 128, 64);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const geometry = new THREE.PlaneGeometry(0.9, 0.45);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'DoorBadge';
                mesh.renderOrder = 5;
                return mesh;
            }

            attachDoorBadgeToDoor(doorMesh, text) {
                if(!doorMesh || !text) return false;
                const badge = this.createDoorBadge(text);
                badge.position.set(0, CONFIG.floorHeight * 0.45, 0.22);
                doorMesh.add(badge);
                return true;
            }

            attachDoorBadgeToFront(obj, text) {
                if(!obj || !text) return false;
                const badge = this.createDoorBadge(text);
                const depth = (obj.geometry?.parameters?.depth || CONFIG.roomDepth) * (obj.scale?.z || 1);
                badge.position.set(0, CONFIG.floorHeight * 0.45, (depth / 2) + 0.05);
                obj.add(badge);
                return true;
            }

            refreshDoorLabels(obj) {
                if(!this.supportsDoorBadge(obj)) return;
                this.ensureLabelDefaults(obj);
                this.clearDoorBadges(obj);
                const text = this.getDoorLabelText(obj);
                if(!text || obj.userData.doorLabelVisible === false) return;

                let attached = false;
                obj.traverse(child => {
                    if(child.userData?.type === 'door') {
                        if(this.attachDoorBadgeToDoor(child, text)) attached = true;
                    }
                });
                if(!attached) this.attachDoorBadgeToFront(obj, text);
            }

            refreshLabelUI(obj) {
                if(!obj || obj.userData.isFurniture) return;
                this.ensureLabelDefaults(obj);
                document.getElementById('labelSizeInput').value = obj.userData.labelScale;
                document.getElementById('labelTextColorInput').value = obj.userData.textColor;
                document.getElementById('labelPosX').value = obj.userData.labelOffset.x;
                document.getElementById('labelPosY').value = obj.userData.labelOffset.y;
                document.getElementById('labelPosZ').value = obj.userData.labelOffset.z;
                document.getElementById('toggleLabelBtn').innerText = obj.userData.labelVisible === false ? 'Afficher' : 'Masquer';
                document.getElementById('toggleAllLabelsBtn').innerText = this.labelsVisible ? 'Masquer tout' : 'Afficher tout';
                const doorBtn = document.getElementById('toggleDoorLabelBtn');
                if(doorBtn) {
                    const supported = this.supportsDoorBadge(obj);
                    doorBtn.disabled = !supported;
                    doorBtn.classList.toggle('opacity-50', !supported);
                    doorBtn.classList.toggle('cursor-not-allowed', !supported);
                    doorBtn.innerText = obj.userData.doorLabelVisible === false ? 'Afficher porte' : 'Masquer porte';
                }
            }

              refreshFurnitureUI(obj) {
                  if(!obj || !obj.userData.isFurniture) return;
                  document.getElementById('furnScaleX').value = obj.scale.x.toFixed(2);
                  document.getElementById('furnScaleY').value = obj.scale.y.toFixed(2);
                  document.getElementById('furnScaleZ').value = obj.scale.z.toFixed(2);
                  const deg = THREE.MathUtils.radToDeg(obj.rotation.y);
                  document.getElementById('furnRotationY').value = Math.round(deg * 100) / 100;
              }

              refreshBreakerUI(obj) {
                  const section = document.getElementById('breakerSection');
                  const list = document.getElementById('breakerRoomsList');
                  if(!section || !list) return;
                  if(!obj || !obj.userData?.isBreaker) {
                      section.classList.add('hidden');
                      list.innerHTML = '';
                      return;
                  }

                  let roomParent = obj;
                  while(roomParent && !roomParent.userData?.type && roomParent.parent) roomParent = roomParent.parent;
                  this.ensureRoomId(roomParent);
                  const rooms = this.listRooms();
                  const feeds = obj.userData.feeds || [];
                  list.innerHTML = '';
                  rooms.sort((a,b) => (a.userData.name||'').localeCompare(b.userData.name||''));
                  rooms.forEach(room => {
                      this.ensureRoomId(room);
                      const id = room.userData.roomId;
                      const wrapper = document.createElement('label');
                      wrapper.className = 'flex items-center gap-2 bg-gray-50 border border-gray-200 rounded px-2 py-1';
                      const input = document.createElement('input');
                      input.type = 'checkbox';
                      input.dataset.roomId = id;
                      input.checked = feeds.includes(id);
                      input.className = 'accent-emerald-500';
                      const text = document.createElement('span');
                      text.className = 'flex-1 text-[11px] text-gray-700';
                      text.textContent = `${room.userData.name || 'Chambre'} (${this.formatFloorLabel(room.userData.floor || 0)})`;
                      wrapper.appendChild(input);
                      wrapper.appendChild(text);
                      list.appendChild(wrapper);
                  });
                  if(rooms.length === 0) list.innerHTML = '<div class="text-[10px] text-gray-400">Aucune chambre disponible</div>';
                  section.classList.remove('hidden');
              }

              updateCableToggleButton() {
                  const btn = document.getElementById('toggleCablesBtn');
                  if(!btn) return;
                  btn.innerHTML = `<i data-lucide="${this.cablesVisible ? 'eye-off' : 'eye'}" size="14"></i>${this.cablesVisible ? 'Masquer le câblage' : 'Afficher le câblage'}`;
                  lucide.createIcons({ root: btn });
              }

              toggleBreakerCables() {
                  this.cablesVisible = !this.cablesVisible;
                  if(this.breakerCableGroup) this.breakerCableGroup.visible = this.cablesVisible;
                  this.updateCableToggleButton();
                  this.stateManager.snapshot();
              }

              setBreakerFeed(breaker, roomId, enabled) {
                  if(!breaker?.userData?.isBreaker) return;
                  if(!breaker.userData.feeds) breaker.userData.feeds = [];
                  const exists = breaker.userData.feeds.includes(roomId);
                  if(enabled && !exists) breaker.userData.feeds.push(roomId);
                  if(!enabled && exists) breaker.userData.feeds = breaker.userData.feeds.filter(id => id !== roomId);
                  this.updateBreakerCables();
                  this.stateManager.snapshot();
              }

              selectAllBreakerRooms() {
                  const breaker = this.selectedObject;
                  if(!breaker?.userData?.isBreaker) return;
                  const rooms = this.listRooms();
                  rooms.forEach(r => this.ensureRoomId(r));
                  breaker.userData.feeds = rooms.map(r => r.userData.roomId);
                  this.updateBreakerCables();
                  this.refreshBreakerUI(breaker);
                  this.stateManager.snapshot();
              }

              updateBreakerCables() {
                  if(!this.breakerCableGroup) return;
                  this.breakerCableGroup.children.forEach(child => { child.geometry?.dispose?.(); child.material?.dispose?.(); });
                  this.breakerCableGroup.clear();
                  this.cableMaterials = [];
                  const rooms = this.listRooms();
                  rooms.forEach(r => this.ensureRoomId(r));
                  const roomIds = rooms.map(r => r.userData.roomId);

                  this.scene.traverse(obj => {
                      if(!obj.userData?.isBreaker) return;
                      if(!Array.isArray(obj.userData.feeds)) obj.userData.feeds = [];
                      obj.userData.feeds = obj.userData.feeds.filter(id => roomIds.includes(id));
                      obj.userData.feeds.forEach(id => {
                          const room = rooms.find(r => r.userData.roomId === id);
                          if(!room) return;
                          const start = obj.getWorldPosition(new THREE.Vector3());
                          start.y += 1.2;
                          const end = room.getWorldPosition(new THREE.Vector3());
                          end.y = this.getFloorY(room.userData.floor || 0) + CONFIG.floorHeight * 0.6;
                          const mid = start.clone().lerp(end, 0.5);
                          mid.y += 1.5;
                          const geometry = new THREE.BufferGeometry().setFromPoints([start, mid, end]);
                          const material = new THREE.LineDashedMaterial({ color: 0xf97316, dashSize: 0.8, gapSize: 0.35, transparent: true, opacity: 0.9 });
                          const line = new THREE.Line(geometry, material);
                          line.computeLineDistances();
                          line.userData = { isCable: true, breakerId: obj.uuid, targetId: id };
                          this.breakerCableGroup.add(line);
                          this.cableMaterials.push(material);
                      });
                  });
                  this.breakerCableGroup.visible = this.cablesVisible;
                  this.updateCableToggleButton();
              }

            updateLabelScale(val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.labelScale = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateLabelTextColor(val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.textColor = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateLabelOffset(axis, val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                if(!this.selectedObject.userData.labelOffset) this.selectedObject.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                this.selectedObject.userData.labelOffset[axis] = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateFurnitureScale(axis, val) {
                if(!this.selectedObject || !this.selectedObject.userData.isFurniture || isNaN(val)) return;
                const safeVal = Math.max(0.2, val);
                this.selectedObject.scale[axis] = safeVal;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.updateStats();
                this.refreshFurnitureUI(this.selectedObject);
            }

            updateFurnitureRotation(deg) {
                if(!this.selectedObject || !this.selectedObject.userData.isFurniture || isNaN(deg)) return;
                const rad = THREE.MathUtils.degToRad(deg);
                this.selectedObject.rotation.y = rad;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.refreshFurnitureUI(this.selectedObject);
            }

            toggleSelectedLabel() {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.labelVisible = !(this.selectedObject.userData.labelVisible !== false);
                this.updateLabelVisibility(this.selectedObject);
                this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            toggleDoorLabel() {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                if(!this.supportsDoorBadge(this.selectedObject)) return;
                this.selectedObject.userData.doorLabelVisible = !(this.selectedObject.userData.doorLabelVisible !== false);
                this.refreshDoorLabels(this.selectedObject);
                this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            toggleAllLabels() {
                this.labelsVisible = !this.labelsVisible;
                this.updateAllLabelVisibility();
                if(this.selectedObject && !this.selectedObject.userData.isFurniture) this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            updateLabelVisibility(obj) {
                const label = obj.getObjectByName('Label');
                if(label) label.visible = this.labelsVisible && obj.userData.labelVisible !== false;
            }

            updateAllLabelVisibility() {
                this.scene.traverse(o => {
                    if(o.userData && o.userData.type && !o.userData.isFurniture) {
                        this.updateLabelVisibility(o);
                    }
                });
            }

            getTargetRoom() {
                if(!this.selectedObject) return null;
                return this.selectedObject.userData.isFurniture ? this.selectedObject.parent : this.selectedObject;
            }

            addFurnitureFromMenu() {
                const target = this.getTargetRoom();
                if(!target || !target.getObjectByName || target.userData.type !== 'Chambre') { this.showToast('Sélectionnez une chambre', 'error'); return; }
                const type = document.getElementById('furnitureSelector').value;
                const factory = FurnitureFactory[type];
                if(!factory) { this.showToast('Objet inconnu', 'error'); return; }
                let container = target.getObjectByName('Furniture');
                if(!container) { container = new THREE.Group(); container.name = 'Furniture'; target.add(container); }
                const item = factory();
                item.position.set(0, item.userData.defaultY || 0, 0);
                  container.add(item);
                  this.snapObject(item);
                  this.refreshDoorLabels(target);
                  this.selectObject(item);
                  this.stateManager.snapshot();
                  this.updateBreakerCables();
                  this.refreshBreakerUI(this.selectedObject);
                  this.showToast(`${item.userData.name} ajouté`, 'success');
              }

            removeFurnitureFromMenu() {
                const target = this.getTargetRoom();
                if(!target || target.userData.type !== 'Chambre') { this.showToast('Sélectionnez une chambre', 'error'); return; }
                const type = document.getElementById('furnitureSelector').value;
                const group = target.getObjectByName('Furniture');
                if(!group) { this.showToast('Aucun mobilier', 'error'); return; }
                for(let i = group.children.length - 1; i >=0; i--) {
                    if(group.children[i].userData.type === type) {
                          group.remove(group.children[i]);
                          this.refreshDoorLabels(target);
                          this.selectObject(target);
                          this.stateManager.snapshot();
                          this.updateBreakerCables();
                          this.showToast('Objet retiré', 'info');
                          return;
                      }
                }
                this.showToast('Aucun objet de ce type', 'error');
            }

            // --- SNAP & CONTRAINTES ---
            snapObject(obj) {
                if (obj.userData.isFurniture) {
                    // 1. VERROUILLAGE Y CONSTANT (Empêche de traverser le sol/plafond)
                    if (obj.userData.defaultY !== undefined) {
                        obj.position.y = obj.userData.defaultY;
                    }

                    // 2. LOGIQUE "AIMANT" MUR (Porte & Fenêtre)
                    if (obj.userData.isWallMounted) {
                        const parent = obj.parent; // Le groupe Chambre
                        // Si la chambre est redimensionnée, on adapte le calcul
                        const w = (CONFIG.roomWidth * parent.scale.x) / 2;
                        const d = (CONFIG.roomDepth * parent.scale.z) / 2;
                        const margin = 0.15;

                        const distN = Math.abs(obj.position.z - (-d)); // Nord
                        const distS = Math.abs(obj.position.z - d);    // Sud
                        const distE = Math.abs(obj.position.x - w);    // Est
                        const distW = Math.abs(obj.position.x - (-w)); // Ouest

                        const min = Math.min(distN, distS, distE, distW);

                        if(min === distN) { // Mur Nord
                            obj.position.z = -d + margin; obj.rotation.y = 0;
                            obj.position.x = Math.max(-w+0.8, Math.min(w-0.8, obj.position.x));
                        } else if (min === distS) { // Mur Sud
                            obj.position.z = d - margin; obj.rotation.y = 0;
                            obj.position.x = Math.max(-w+0.8, Math.min(w-0.8, obj.position.x));
                          } else if (min === distE) { // Mur Est
                              obj.position.x = w - margin; obj.rotation.y = Math.PI/2;
                              obj.position.z = Math.max(-d+0.8, Math.min(d-0.8, obj.position.z));
                          } else { // Mur Ouest
                              obj.position.x = -w + margin; obj.rotation.y = Math.PI/2;
                              obj.position.z = Math.max(-d+0.8, Math.min(d-0.8, obj.position.z));
                          }

                          if(obj.userData.wallOffset) {
                              const dir = new THREE.Vector3(
                                  min === distE ? 1 : min === distW ? -1 : 0,
                                  0,
                                  min === distS ? 1 : min === distN ? -1 : 0
                              );
                              obj.position.addScaledVector(dir, obj.userData.wallOffset);
                          }

                      } else {
                          // 3. MEUBLES CLASSIQUES
                        if(this.control.mode === 'translate') {
                            obj.position.x = Math.round(obj.position.x / 0.1) * 0.1;
                            obj.position.z = Math.round(obj.position.z / 0.1) * 0.1;
                        }

                        // CONFINEMENT (Reste dans la pièce)
                        const parent = obj.parent;
                        const roomW = CONFIG.roomWidth * parent.scale.x;
                        const roomD = CONFIG.roomDepth * parent.scale.z;
                        const padding = 0.2;
                        const dimsX = (obj.userData.dims?.x || 0.5) * (obj.scale?.x || 1);
                        const dimsZ = (obj.userData.dims?.z || 0.5) * (obj.scale?.z || 1);
                        const rotY = obj.rotation?.y || 0;
                        const cosY = Math.abs(Math.cos(rotY));
                        const sinY = Math.abs(Math.sin(rotY));

                        // Rayon projeté sur les axes après rotation (AABB du rectangle tourné)
                        const halfX = (dimsX * cosY + dimsZ * sinY) / 2;
                        const halfZ = (dimsZ * cosY + dimsX * sinY) / 2;

                          const minX = - (roomW / 2) + halfX + padding; const maxX = (roomW / 2) - halfX - padding;
                          const minZ = - (roomD / 2) + halfZ + padding; const maxZ = (roomD / 2) - halfZ - padding;

                          obj.position.x = Math.max(minX, Math.min(maxX, obj.position.x));
                          obj.position.z = Math.max(minZ, Math.min(maxZ, obj.position.z));
                      }

                  } else {
                    // 4. DÉPLACEMENT STRUCTURE
                    if(this.control.mode === 'translate') {
                        obj.position.x = Math.round(obj.position.x / CONFIG.gridSize) * CONFIG.gridSize;
                        obj.position.z = Math.round(obj.position.z / CONFIG.gridSize) * CONFIG.gridSize;
                        obj.position.y = this.getFloorY(obj.userData.floor || 0);
                      } else if (this.control.mode === 'rotate') {
                          obj.rotation.x = 0; obj.rotation.z = 0;
                          obj.rotation.y = Math.round(obj.rotation.y / (Math.PI/2)) * (Math.PI/2);
                      }
                  }
                  if(obj.userData?.isBreaker || obj.userData?.type === 'Chambre') this.updateBreakerCables();
              }

            // --- EVENTS ---
            onPointerDown(event) {
                if(this.isGlobalView) return;
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.pointer, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                let target = null;

                // --- PASSE 1 : RECHERCHE DE MEUBLES (PRIORITÉ ABSOLUE) ---
                for (let hit of intersects) {
                    if (hit.object.type === 'Sprite' || hit.object.name === 'Ground' || hit.object.userData?.isCable) continue;
                    
                    let node = hit.object;
                    let foundFurniture = null;
                    while(node && node.parent) {
                        if(node.userData && node.userData.isFurniture) {
                            let root = node; while(root.parent && root.parent !== this.scene) root = root.parent;
                            if(root.userData.floor === this.floors.current) foundFurniture = node;
                            break;
                        }
                        node = node.parent;
                    }
                    if(foundFurniture) {
                        target = foundFurniture;
                        break; // Trouvé ! On arrête tout de suite
                    }
                }

                // --- PASSE 2 : SI AUCUN MEUBLE, RECHERCHE DE STRUCTURE ---
                if (!target) {
                    for (let hit of intersects) {
                        if (hit.object.type === 'Sprite' || hit.object.name === 'Ground' || hit.object.userData?.isCable) continue;
                        let node = hit.object;
                        let foundStructure = null;
                        while(node && node.parent) {
                            if(node.parent === this.scene && node.userData.type) {
                                if(node.userData.floor === this.floors.current) foundStructure = node;
                                break;
                            }
                            node = node.parent;
                        }
                        if(foundStructure) {
                            target = foundStructure;
                            break;
                        }
                    }
                }

                this.selectObject(target);
            }

              selectObject(obj) {
                  this.selectedObject = obj;
                  const panel = document.getElementById('propPanel');
                  const dupInput = document.getElementById('duplicateFloorTarget');

                  if (obj) {
                      this.control.attach(obj);
                      panel.classList.remove('opacity-50', 'pointer-events-none', 'scale-95');
                      panel.classList.add('opacity-100', 'scale-100');
                    document.getElementById('propName').value = obj.userData.name || '';
                    if(!obj.userData.isFurniture) this.setColorTarget(this.colorTarget);

                    if(obj.userData.isFurniture) {
                        document.getElementById('propTitle').innerText = "MOBILIER";
                        document.getElementById('colorSection').classList.add('hidden');
                        document.getElementById('sizeSection').classList.add('hidden');
                          document.getElementById('labelSection').classList.add('hidden');
                          document.getElementById('furnitureSection').classList.add('hidden');
                          document.getElementById('furnitureTransformSection').classList.remove('hidden');
                          this.refreshFurnitureUI(obj);
                          this.control.showY = true;
                          this.refreshBreakerUI(obj);
                      } else {
                          document.getElementById('propTitle').innerText = "PROPRIÉTÉS";
                          document.getElementById('colorSection').classList.remove('hidden');
                          document.getElementById('sizeSection').classList.remove('hidden');
                          document.getElementById('labelSection').classList.remove('hidden');
                          document.getElementById('furnitureSection').classList.remove('hidden');
                          document.getElementById('furnitureTransformSection').classList.add('hidden');
                          this.refreshLabelUI(obj);
                          this.control.showY = false;
                          this.refreshBreakerUI(null);
                      }
                      if(dupInput) dupInput.value = obj.userData.floor ?? this.floors.current;
                  } else {
                      this.control.detach();
                      panel.classList.add('opacity-50', 'pointer-events-none', 'scale-95');
                      document.getElementById('furnitureTransformSection').classList.add('hidden');
                      this.refreshBreakerUI(null);
                      if(dupInput) dupInput.value = this.floors.current;
                  }
                  this.updateSelectionChips();
              }

            // ... Rest (setMode, changeFloor, etc) same as before ...
            setMode(mode) {
                this.control.setMode(mode);
                document.querySelectorAll('#toolTranslate, #toolRotate, #toolScale').forEach(el => el.classList.remove('text-blue-600', 'bg-blue-50'));
                const id = 'tool' + mode.charAt(0).toUpperCase() + mode.slice(1);
                document.getElementById(id).classList.add('text-blue-600', 'bg-blue-50');
                this.updateSelectionChips();
            }

            changeFloor(delta) {
                const next = this.floors.current + delta;
                if (next < 0 || next > this.floors.max) return;
                this.floors.current = next;
                this.updateFloorVisibility(); this.updateUI(); this.selectObject(null);
                this.gridHelper.position.y = this.getFloorY(this.floors.current);
                this.updateSelectionChips();
            }

            addFloor() { this.floors.max++; this.changeFloor(1); this.showToast(`Étage ${this.floors.current} créé`, 'success'); this.stateManager.snapshot(); }

            cloneCurrentFloor() {
                const currentObjects = [];
                this.scene.traverse(obj => {
                    if(obj.userData && obj.userData.floor === this.floors.current && obj.userData.type) currentObjects.push(obj);
                });
                if(currentObjects.length === 0) { this.showToast('Étage vide', 'error'); return; }
                this.addFloor();
                currentObjects.forEach(original => {
                    const furnitureList = [];
                    const fGroup = original.getObjectByName('Furniture');
                  if(fGroup) fGroup.children.forEach(c => furnitureList.push({type: c.userData.type, pos: c.position.toArray(), rot: c.rotation.toArray(), userData: c.userData}));
                    if(original.userData.type === 'Exterieur') return;
                    const baseType = original.userData.type === 'Chambre' ? 'room' : original.userData.type === 'Couloir' ? 'corridor' : (original.userData.type === 'Escalier' ? 'stairs' : 'generic');
                    const clone = this.createBlock(baseType, furnitureList);
                      if(clone) {
                          clone.position.x = original.position.x; clone.position.z = original.position.z; clone.rotation.copy(original.rotation);
                          clone.userData = JSON.parse(JSON.stringify(original.userData));
                          clone.userData.floor = this.floors.current;
                          if(clone.userData.type === 'Chambre') this.ensureRoomId(clone, true);
                          this.ensureLabelDefaults(clone);
                          if(clone.userData.type === 'Chambre') this.setRoomWallColor(clone, clone.userData.wallColor || '#6366f1');
                          if(clone.userData.labelText) this.addLabel(clone, clone.userData.labelText);
                      }
                });
                this.stateManager.snapshot(); this.updateStats();
            }

            updateFloorVisibility() {
                this.scene.traverse(obj => {
                    if(obj.userData && obj.userData.type) {
                        const isCurrent = obj.userData.floor === this.floors.current;
                        if(this.isGlobalView) { obj.visible = true; this.setOpacity(obj, 1); } 
                        else {
                            if (obj.userData.floor > this.floors.current) obj.visible = false;
                            else if (isCurrent) { obj.visible = true; this.setOpacity(obj, 1); }
                            else { obj.visible = true; this.setOpacity(obj, 0.1); }
                        }
                    }
                });
            }

            setOpacity(obj, val) {
                obj.traverse(child => {
                    if(child.isMesh) {
                        if(child.material.transparent && child.material.opacity < 0.8 && val === 1) return;
                        if(Array.isArray(child.material)) child.material.forEach(m => { m.transparent = val < 1; m.opacity = val; });
                        else { child.material.transparent = val < 1; child.material.opacity = val; }
                    }
                    if(child.name === 'Label') child.visible = val > 0.5 && this.labelsVisible && child.parent?.userData.labelVisible !== false;
                });
            }

            setGlobalView(isGlobal) {
                this.isGlobalView = isGlobal;
                document.getElementById('viewFloor').classList.toggle('active', !isGlobal);
                document.getElementById('viewGlobal').classList.toggle('active', isGlobal);
                document.getElementById('viewGlobal').classList.toggle('bg-white/50', !isGlobal);
                this.selectObject(null); this.control.enabled = !isGlobal; this.gridHelper.visible = !isGlobal;
                if(isGlobal) { this.camera.position.set(50, 50, 50); this.camera.lookAt(0, (this.floors.max * (CONFIG.floorHeight + CONFIG.floorGap))/2, 0); }
                else { this.changeFloor(0); }
                document.getElementById('viewHint').textContent = isGlobal ? 'Vue globale multi-niveaux' : 'Exploration étage en cours';
                this.updateFloorVisibility();
                this.updateSelectionChips();
            }

            applyPresetRotation(direction) {
                if(!this.selectedObject) return;
                const angleDeg = parseFloat(document.getElementById('rotationAngleSelect').value) || 0;
                if(angleDeg === 0) return;
                const axis = document.getElementById('rotationAxisSelect').value || 'y';
                const delta = (angleDeg * Math.PI / 180) * (direction === 'cw' ? 1 : -1);
                if(!['x','y','z'].includes(axis)) return;
                this.selectedObject.rotation[axis] += delta;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.updateSelectionChips();
                this.showToast(`Rotation ${direction === 'cw' ? '+' : '-'}${angleDeg}°`, 'info');
            }

            setColorTarget(target) {
                this.colorTarget = target;
                const blockBtn = document.getElementById('targetBlock');
                const labelBtn = document.getElementById('targetLabel');
                if(blockBtn && labelBtn) {
                    blockBtn.classList.toggle('bg-white', target === 'block');
                    blockBtn.classList.toggle('shadow-sm', target === 'block');
                    blockBtn.classList.toggle('text-gray-800', target === 'block');
                    blockBtn.classList.toggle('text-gray-400', target !== 'block');
                    labelBtn.classList.toggle('bg-white', target === 'label');
                    labelBtn.classList.toggle('shadow-sm', target === 'label');
                    labelBtn.classList.toggle('text-gray-800', target === 'label');
                    labelBtn.classList.toggle('text-gray-400', target !== 'label');
                }
                const badge = document.getElementById('colorTargetBadge');
                if(badge) {
                    badge.innerHTML = `<i data-lucide="${target === 'block' ? 'brick-wall' : 'sticky-note'}" size="14"></i>${target === 'block' ? 'Murs' : 'Étiquette'}`;
                    lucide.createIcons({ root: badge });
                }
                this.updateSelectionChips();
            }

            formatFloorLabel(floor) {
                return floor === 0 ? 'RDC' : `Étage ${floor}`;
            }

            updateSelectionChips() {
                const selectionChip = document.getElementById('selectionChip');
                const summary = document.getElementById('selectionSummary');
                const floorBadge = document.getElementById('floorContextBadge');
                const modeChip = document.getElementById('modeChip');
                if(modeChip) modeChip.textContent = `Mode ${this.control?.getMode() === 'translate' ? 'déplacement' : this.control?.getMode() === 'rotate' ? 'rotation' : 'échelle'}`;
                if(!selectionChip || !summary || !floorBadge) return;
                if(this.selectedObject) {
                    const type = this.selectedObject.userData.isFurniture ? 'Mobilier' : (this.selectedObject.userData.type || 'Objet');
                    const label = this.selectedObject.userData.name || this.selectedObject.userData.labelText || 'Sans nom';
                    selectionChip.textContent = `${type}`;
                    selectionChip.className = 'pill bg-emerald-600/90';
                    summary.textContent = `${label} • ${this.formatFloorLabel(this.selectedObject.userData.floor || 0)}`;
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.selectedObject.userData.floor || 0)}`;
                    lucide.createIcons({ root: floorBadge });
                } else {
                    selectionChip.textContent = 'Aucune sélection';
                    selectionChip.className = 'pill bg-slate-500/80';
                    summary.textContent = 'Inspecteur inactif';
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.floors.current)}`;
                    lucide.createIcons({ root: floorBadge });
                }
            }

            setRoomWallColor(room, hex) {
                if(!room || room.userData.type !== 'Chambre') return;
                const shell = room.getObjectByName('RoomShell');
                if(shell) {
                    shell.traverse(child => {
                        if(child.isMesh && child.userData?.isWall) child.material.color.set(hex);
                    });
                }
                room.userData.wallColor = hex;
            }

            applyColor(hex) {
                if(!this.selectedObject) return;
                const obj = this.selectedObject;
                if(obj.userData.isFurniture) return;
                this.ensureLabelDefaults(obj);
                if(this.colorTarget === 'block') {
                    if(obj.userData.type === 'Chambre') this.setRoomWallColor(obj, hex);
                    else {
                        const shell = obj.getObjectByName('RoomShell');
                        if(shell) {
                            shell.traverse(child => { if(child.isMesh) child.material.color.set(hex); });
                        } else { obj.traverse(c => { if(c.isMesh) c.material.color.set(hex); }); }
                    }
                } else {
                    obj.userData.labelColor = hex; this.addLabel(obj, obj.userData.labelText);
                }
                this.stateManager.snapshot();
            }

            updateObjectName() {
                if(!this.selectedObject) return;
                const val = document.getElementById('propName').value;
                if(val) {
                    this.selectedObject.userData.name = val;
                    if(this.selectedObject.userData.isFurniture) { }
                    else if(val.length < 5) { this.selectedObject.userData.labelText = val; this.addLabel(this.selectedObject, val); }
                    this.refreshDoorLabels(this.selectedObject);
                    this.showToast('Nom mis à jour', 'success'); this.stateManager.snapshot();
                }
            }

            resizeSelection(size) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                const scales = { 'S': [0.8, 1, 0.8], 'M': [1, 1, 1], 'L': [1.5, 1, 1.2] };
                const s = scales[size];
                this.selectedObject.scale.set(s[0], s[1], s[2]);
                this.snapObject(this.selectedObject); 
                this.stateManager.snapshot(); this.updateStats();
            }

            duplicateSelection() {
                if(!this.selectedObject) return;
                const dupInput = document.getElementById('duplicateFloorTarget');
                let targetFloor = this.floors.current;
                if(dupInput) {
                    const parsed = parseInt(dupInput.value);
                    if(!isNaN(parsed)) targetFloor = Math.max(0, parsed);
                }
                if(targetFloor > this.floors.max) { this.floors.max = targetFloor; this.updateUI(); }

                if(this.selectedObject.userData.isFurniture) {
                    const clone = this.selectedObject.clone();
                    clone.position.x += 0.5; clone.position.z += 0.5;
                    this.selectedObject.parent.add(clone); this.selectObject(clone);
                } else {
                    const original = this.selectedObject;
                    const furnitureList = [];
                    const fGroup = original.getObjectByName('Furniture');
                  if(fGroup) fGroup.children.forEach(c => furnitureList.push({type: c.userData.type, pos: c.position.toArray(), rot: c.rotation.toArray(), userData: c.userData}));
                    const baseType = original.userData.type === 'Chambre' ? 'room' : original.userData.type === 'Couloir' ? 'corridor' : (original.userData.type === 'Escalier' ? 'stairs' : 'generic');
                    let clone;
                    if(original.userData.type === 'Exterieur') {
                        clone = this.createExterior(original.userData.element, targetFloor);
                    } else {
                          clone = this.createBlock(baseType, furnitureList, targetFloor);
                      }
                      if(clone) {
                          const offset = targetFloor === original.userData.floor ? 2 : 0;
                          clone.position.set(original.position.x + offset, this.getFloorY(targetFloor), original.position.z + offset);
                          clone.rotation.copy(original.rotation);
                          clone.userData = JSON.parse(JSON.stringify(original.userData));
                          clone.userData.floor = targetFloor;
                          if(clone.userData.type === 'Chambre') this.ensureRoomId(clone, true);
                          this.ensureLabelDefaults(clone);
                          if(clone.userData.type === 'Chambre') this.setRoomWallColor(clone, clone.userData.wallColor || '#6366f1');
                          if(!isNaN(parseInt(clone.userData.labelText))) {
                              const newNum = this.roomCounter++; clone.userData.labelText = newNum.toString(); clone.userData.name = `Chambre ${newNum}`;
                              this.addLabel(clone, clone.userData.labelText);
                          }
                          this.refreshDoorLabels(clone);
                      }
                  }
                  this.updateFloorVisibility();
                  this.updateBreakerCables();
                  this.stateManager.snapshot(); this.updateStats(); this.showToast(`Objet dupliqué vers ${this.formatFloorLabel(targetFloor)}`, 'success');
              }

            deleteSelection() {
                if(!this.selectedObject) return;
                  if(this.selectedObject.userData.isFurniture) this.selectedObject.parent.remove(this.selectedObject);
                  else this.scene.remove(this.selectedObject);
                  this.selectObject(null); this.updateBreakerCables(); this.stateManager.snapshot(); this.updateStats(); this.showToast('Supprimé', 'info');
              }

            serializeScene() {
                const objects = [];
                this.scene.traverse(obj => {
                      if(obj.userData && obj.userData.type) {
                          const furniture = [];
                          const fGroup = obj.getObjectByName('Furniture');
                          if(fGroup) fGroup.children.forEach(c => furniture.push({ type: c.userData.type, pos: c.position.toArray(), rot: c.rotation.toArray(), userData: c.userData }));
                          objects.push({ type: obj.userData.type, position: obj.position.toArray(), rotation: obj.rotation.toArray(), scale: obj.scale.toArray(), userData: obj.userData, furniture: furniture });
                      }
                  });
                  return { version: 2.7, timestamp: Date.now(), roomCounter: this.roomCounter, floors: this.floors, objects: objects, labelsVisible: this.labelsVisible, breakerCablesVisible: this.cablesVisible };
              }

            saveToFile() {
                  const data = JSON.stringify(this.serializeScene(), null, 2);
                  const blob = new Blob([data], {type: 'application/json'});
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a'); a.href = url; a.download = `flexilogis_v2.7_${new Date().toISOString().slice(0,10)}.json`; a.click();
                  this.showToast('Projet sauvegardé', 'success');
              }

            loadScene(state) {
                  this.resetScene(false); this.roomCounter = state.roomCounter; this.floors = state.floors; this.labelsVisible = state.labelsVisible !== undefined ? state.labelsVisible : true; this.cablesVisible = state.breakerCablesVisible !== undefined ? state.breakerCablesVisible : true;
                  state.objects.forEach(data => {
                      const savedCurrent = this.floors.current; this.floors.current = data.userData.floor;
                      let obj;
                    if(data.type === 'Chambre') obj = this.createBlock('room', data.furniture);
                    else if(data.type === 'Couloir') obj = this.createBlock('corridor');
                    else if(data.type === 'Zone' || data.type === 'Generic') obj = this.createBlock('generic');
                    else if(data.type === 'Escalier') obj = this.createBlock('stairs');
                    else if(data.userData?.type === 'Exterieur') obj = this.createExterior(data.userData.element || 'pelouse', data.userData.floor || 0);
                      if(obj) {
                          obj.position.fromArray(data.position); obj.rotation.fromArray(data.rotation); obj.scale.fromArray(data.scale); obj.userData = data.userData;
                          obj.position.y = this.getFloorY(obj.userData.floor || 0);
                          if(obj.userData.type === 'Chambre') this.ensureRoomId(obj);
                          this.ensureLabelDefaults(obj);
                          if(obj.userData.labelText) this.addLabel(obj, obj.userData.labelText);
                          if(obj.userData.type === 'Chambre') this.setRoomWallColor(obj, obj.userData.wallColor || '#6366f1');
                        this.refreshDoorLabels(obj);
                        if(obj.userData.labelColor) this.selectedObject = obj;
                    }
                      this.floors.current = savedCurrent;
                  });
                  this.updateFloorVisibility(); this.updateUI(); this.updateStats(); this.updateAllLabelVisibility();
                  this.updateBreakerCables();
                  this.updateSelectionChips();
              }

            loadFile(event) {
                const file = event.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => { try { this.loadScene(JSON.parse(e.target.result)); this.showToast('Chargé', 'success'); } catch(err) { console.error(err); this.showToast('Erreur', 'error'); } };
                reader.readAsText(file); event.target.value = '';
            }

            resetScene(createDefault = true) {
                  const toRemove = []; this.scene.traverse(obj => { if(obj.userData && obj.userData.type) toRemove.push(obj); });
                  toRemove.forEach(o => this.scene.remove(o));
                  if(this.breakerCableGroup) this.breakerCableGroup.clear();
                  this.cableMaterials = [];
                  this.roomCounter = 1; this.floors = { current: 0, max: 0 }; this.labelsVisible = true; this.cablesVisible = true; this.updateUI(); this.updateStats();
                  this.updateCableToggleButton();
                  if(createDefault) { this.createBlock('room'); this.stateManager.history = []; this.stateManager.snapshot(); this.showToast('Reset', 'info'); }
              }

            updateUI() {
                document.getElementById('floorNumberDisplay').innerText = this.floors.current;
                document.getElementById('floorBadge').innerText = this.floors.current === 0 ? "RDC" : "ÉTAGE " + this.floors.current;
                document.getElementById('floorDown').disabled = this.floors.current === 0;
                document.getElementById('floorUp').disabled = this.floors.current === this.floors.max;
                const dupInput = document.getElementById('duplicateFloorTarget');
                if(dupInput) dupInput.value = this.floors.current;
                const floorBadge = document.getElementById('floorContextBadge');
                if(floorBadge) {
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.floors.current)}`;
                    lucide.createIcons({ root: floorBadge });
                }
            }

            updateStats() {
                let count = 0; let area = 0;
                this.scene.traverse(obj => { if(obj.userData && obj.userData.type === 'Chambre') { count++; area += (obj.scale.x * 4) * (obj.scale.z * 6); } });
                document.getElementById('statRooms').innerText = count; document.getElementById('statArea').innerText = Math.round(area) + " m²";
            }

            showToast(msg, type = 'success') {
                const container = document.getElementById('toast-container');
                const el = document.createElement('div'); el.className = `toast ${type}`;
                let icon = 'check-circle'; if(type==='error') icon='alert-circle'; if(type==='info') icon='info';
                el.innerHTML = `<i data-lucide="${icon}" size="18"></i> <span>${msg}</span>`;
                container.appendChild(el); lucide.createIcons({ root: el });
                setTimeout(() => { el.style.animation = 'fadeOut 0.3s forwards'; setTimeout(() => el.remove(), 300); }, 3000);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            onKeyDown(e) {
                if(e.target.tagName === 'INPUT') return; 
                const k = e.key.toLowerCase();
                if((e.ctrlKey||e.metaKey) && k === 'z') { e.preventDefault(); this.stateManager.undo(); return; }
                if((e.ctrlKey||e.metaKey) && k === 'y') { e.preventDefault(); this.stateManager.redo(); return; }
                if(k === 'w') this.setMode('translate'); if(k === 'e') this.setMode('rotate'); if(k === 'r') this.setMode('scale');
                if(k === 'delete' || k === 'backspace') this.deleteSelection();
            }

            animate() {
                this.orbit.update();
                  if(!this.isGlobalView) {
                      this.scene.traverse(obj => {
                          if(obj.name === 'Label') {
                              const dist = obj.position.distanceTo(this.camera.position);
                              const scale = Math.max(1.5, dist / 15);
                              const base = obj.parent?.userData?.labelScale || CONFIG.defaultLabelScale;
                              obj.scale.set(scale * 2 * base, scale * base, 1);
                              obj.visible = this.labelsVisible && obj.parent?.userData.labelVisible !== false;
                          }
                      });
                  }
                  if(this.cablesVisible && this.cableMaterials.length) {
                      this.cableMaterials.forEach(mat => { mat.dashOffset -= 0.01; mat.needsUpdate = true; });
                  }
                  this.renderer.render(this.scene, this.camera);
              }
        }

        const app = new HotelArchitect();
        window.app = app; 
    </script>
</body>
</html>
