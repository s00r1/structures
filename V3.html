<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Architecte Hôtel Pro - Flexilogis 3D</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0f172a; user-select: none; }
        
        /* Canvas Container */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: linear-gradient(to bottom, #e0f2fe, #f0f9ff); }

        /* UI Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.4); }

        /* Custom UI Components */
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel-title {
            letter-spacing: 0.08em;
            color: #0f172a;
        }

        .tab-pill {
            flex: 1 1 0;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 800;
            border-radius: 12px;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: rgba(15, 23, 42, 0.04);
            color: #475569;
        }

        .tab-pill.active {
            background: linear-gradient(135deg, #0ea5e9, #6366f1);
            color: white;
            border-color: rgba(255,255,255,0.3);
            box-shadow: 0 8px 24px rgba(14,165,233,0.25);
        }

        .subsection-card {
            border: 1px dashed rgba(15,23,42,0.12);
            background: rgba(255,255,255,0.75);
        }

        .chip {
            border: 1px solid rgba(148, 163, 184, 0.4);
            padding: 3px 8px;
            border-radius: 9999px;
            font-size: 10px;
            font-weight: 700;
            color: #0f172a;
            background: rgba(241, 245, 249, 0.8);
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .pill {
            background: #0ea5e9;
            color: #ecfeff;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 700;
        }

        .subtle-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: #94a3b8;
        }

        .soft-card {
            border: 1px dashed rgba(15, 23, 42, 0.08);
            background: rgba(248, 250, 252, 0.6);
        }

        .btn-tool { transition: all 0.2s ease; }
        .btn-tool:active { transform: scale(0.95); }
        .btn-tool.active { background-color: #3b82f6; color: white; border-color: #2563eb; }

        .color-swatch { transition: transform 0.2s; cursor: pointer; border: 2px solid transparent; }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: #3b82f6; box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6; transform: scale(1.1); }

        /* Toast Notification */
        #toast-container {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            display: flex; flex-direction: column; gap: 10px; pointer-events: none;
        }
        .toast {
            background: #1e293b; color: white; padding: 12px 24px; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2); font-size: 0.9rem;
            animation: slideIn 0.3s ease-out forwards; pointer-events: auto;
            display: flex; align-items: center; gap: 8px; border-left: 4px solid #3b82f6;
        }
        .toast.success { border-left-color: #22c55e; }
        .toast.error { border-left-color: #ef4444; }
        .toast.info { border-left-color: #3b82f6; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(10px); }
        }

        /* Loader */
        #loader {
            position: fixed; inset: 0; background: #0f172a; z-index: 9999;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1);
            border-left-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Loader -->
    <div id="loader">
        <div class="spinner mb-4"></div>
        <div class="text-white font-semibold tracking-wider">CHARGEMENT FLEXILOGIS...</div>
    </div>

    <!-- 3D Container -->
    <div id="canvas-container"></div>
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <!-- Command Ribbon -->
    <div class="absolute top-3 left-1/2 -translate-x-1/2 w-[720px] z-20">
        <div class="glass-panel rounded-2xl p-4 shadow-xl border border-white/60">
            <div class="flex items-center justify-between gap-4">
                <div class="flex items-center gap-3">
                    <div class="bg-sky-600 text-white p-2 rounded-xl shadow-inner"><i data-lucide="sparkles" size="20"></i></div>
                    <div>
                        <div class="text-xs uppercase tracking-wider text-slate-500 font-bold">Assistant de conception</div>
                        <div class="text-lg font-extrabold text-slate-900">Flexilogis Experience</div>
                    </div>
                </div>
                <div class="flex items-center gap-2 flex-wrap justify-end">
                    <div class="flex bg-slate-100 rounded-xl p-1 gap-1" id="modeSwitcher">
                        <button data-mode-btn="chambre" class="tab-pill active"><i data-lucide="layout-template" size="14"></i>Mode chambre</button>
                        <button data-mode-btn="construction" class="tab-pill"><i data-lucide="blocks" size="14"></i>Construction</button>
                        <button data-mode-btn="exterieur" class="tab-pill"><i data-lucide="trees" size="14"></i>Extérieur</button>
                    </div>
                    <span id="modeChip" class="pill bg-sky-600/90">Mode déplacement</span>
                    <span id="selectionChip" class="pill bg-emerald-600/90">Aucune sélection</span>
                    <button id="selectionLockBtn" class="pill bg-slate-700/80 text-white flex items-center gap-1 hover:bg-slate-800 transition" title="Verrouiller la sélection">
                        <i data-lucide="unlock" size="14"></i><span>Sélection libre</span>
                    </button>
                </div>
            </div>
            <div class="mt-3 grid grid-cols-3 gap-2 text-xs text-slate-500">
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="mouse-pointer-2" size="14"></i><span>Orbiter + cliquer pour cibler</span></div>
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="scan" size="14"></i><span id="selectionSummary">Inspecteur inactif</span></div>
                <div class="soft-card rounded-xl p-2 flex items-center gap-2"><i data-lucide="keyboard" size="14"></i><span>W/E/R · Ctrl+Z/Y</span></div>
            </div>
        </div>
    </div>

    <!-- LEFT PANEL: Creation & Tools -->
    <div class="absolute top-4 left-4 w-80 flex flex-col gap-3 z-10 max-h-[95vh] overflow-y-auto pr-1">

        <!-- Header -->
        <div class="glass-panel p-4 rounded-xl flex items-center justify-between">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 p-1.5 rounded-lg text-white"><i data-lucide="building-2" size="20"></i></div>
                <div>
                    <h1 class="font-bold text-gray-800 text-sm leading-tight">Flexilogis Studio</h1>
                    <div class="text-[10px] text-gray-500 font-mono">UI refonte complète</div>
                </div>
            </div>
            <!-- Undo/Redo Mini -->
            <div class="flex gap-1">
                <button id="undoBtn" class="p-1.5 hover:bg-gray-100 rounded text-gray-600 disabled:opacity-30" title="Annuler (Ctrl+Z)">
                    <i data-lucide="undo-2" size="16"></i>
                </button>
                <button id="redoBtn" class="p-1.5 hover:bg-gray-100 rounded text-gray-600 disabled:opacity-30" title="Rétablir (Ctrl+Y)">
                    <i data-lucide="redo-2" size="16"></i>
                </button>
            </div>
        </div>

        <!-- Floor Management -->
        <div class="glass-panel p-3 rounded-xl">
            <div class="flex justify-between items-center mb-2">
                <span class="text-xs font-bold text-gray-500 uppercase">Niveau Actif</span>
                <span id="floorBadge" class="bg-blue-100 text-blue-700 text-xs px-2 py-0.5 rounded font-bold border border-blue-200">RDC</span>
            </div>

            <div class="flex items-center gap-2 mb-2">
                <button id="floorDown" class="w-8 h-8 flex items-center justify-center bg-white border border-gray-200 rounded hover:bg-gray-50 text-gray-600 transition">
                    <i data-lucide="chevron-down" size="18"></i>
                </button>
                <div class="flex-1 h-8 bg-white border border-gray-200 rounded flex items-center justify-center font-bold text-gray-700 shadow-inner">
                    <span id="floorNumberDisplay">0</span>
                </div>
                <button id="floorUp" class="w-8 h-8 flex items-center justify-center bg-white border border-gray-200 rounded hover:bg-gray-50 text-gray-600 transition">
                    <i data-lucide="chevron-up" size="18"></i>
                </button>
            </div>

            <div class="grid grid-cols-2 gap-2">
                <button id="addFloorBtn" class="py-1.5 bg-blue-600 text-white text-xs font-bold rounded hover:bg-blue-700 transition flex items-center justify-center gap-1">
                    <i data-lucide="plus" size="12"></i> Ajouter
                </button>
                <button id="cloneFloorBtn" class="py-1.5 bg-indigo-100 text-indigo-700 text-xs font-bold rounded hover:bg-indigo-200 transition border border-indigo-200 flex items-center justify-center gap-1">
                    <i data-lucide="copy" size="12"></i> Dupliquer
                </button>
            </div>
        </div>

        <!-- Creation Tabs -->
        <div class="glass-panel p-3 rounded-xl">
            <div class="grid grid-cols-3 gap-2 mb-3" id="builderTabs">
                <button data-builder-tab="chambre" class="tab-pill active"><i data-lucide="bed-double" size="14"></i>Chambres</button>
                <button data-builder-tab="construction" class="tab-pill"><i data-lucide="panels-top-left" size="14"></i>Construction</button>
                <button data-builder-tab="exterieur" class="tab-pill"><i data-lucide="tree-palm" size="14"></i>Extérieur</button>
            </div>

            <div class="flex flex-col gap-3">
                <!-- Panel Chambres -->
                <div data-builder-panel="chambre" class="flex flex-col gap-3">
                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Structures prêtes</span>
                            <span class="chip">Modes pièce</span>
                        </div>
                        <div class="space-y-2 text-[11px] text-slate-600">
                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="app.createPresetSpace('cuisine','petite')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-sky-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-orange-100 text-orange-600 flex items-center justify-center"><i data-lucide="chef-hat" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Cuisine</div><div class="text-[10px] text-gray-500">Petite · pack complet</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('cuisine','grande')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-sky-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-orange-100 text-orange-600 flex items-center justify-center"><i data-lucide="chef-hat" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Cuisine</div><div class="text-[10px] text-gray-500">Grande · îlot & électroménager</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('bain','moyenne')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-cyan-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-cyan-100 text-cyan-600 flex items-center justify-center"><i data-lucide="shower-head" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Salle de bain</div><div class="text-[10px] text-gray-500">Douche, WC, évier</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('buanderie','moyenne')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-emerald-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-emerald-100 text-emerald-600 flex items-center justify-center"><i data-lucide="washing-machine" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Buanderie</div><div class="text-[10px] text-gray-500">Lave-linge + sèche-linge</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('atelier','grande')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-amber-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-amber-100 text-amber-600 flex items-center justify-center"><i data-lucide="hammer" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Atelier</div><div class="text-[10px] text-gray-500">Etabli & rangements</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('bureau','moyenne')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-indigo-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-indigo-100 text-indigo-600 flex items-center justify-center"><i data-lucide="briefcase" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Bureau</div><div class="text-[10px] text-gray-500">Plan de travail + sièges</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('reserve','moyenne')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-lime-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-lime-100 text-lime-600 flex items-center justify-center"><i data-lucide="archive" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Réserve</div><div class="text-[10px] text-gray-500">Racks & stockage</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('lingerie','petite')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-pink-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-pink-100 text-pink-600 flex items-center justify-center"><i data-lucide="hanger" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Lingerie</div><div class="text-[10px] text-gray-500">Armoire, penderie</div></div>
                                </button>
                                <button onclick="app.createPresetSpace('reunion','grande')" class="p-2 rounded-lg bg-white border border-gray-200 hover:border-purple-400 transition flex items-start gap-2">
                                    <div class="w-8 h-8 rounded bg-purple-100 text-purple-600 flex items-center justify-center"><i data-lucide="presentation" size="16"></i></div>
                                    <div class="text-left flex-1"><div class="font-bold text-gray-700">Réunion</div><div class="text-[10px] text-gray-500">Grande table + écrans</div></div>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Bibliothèque</span>
                            <span class="chip">Plans rapides</span>
                        </div>
                        <div class="space-y-2">
                            <button onclick="app.createBlock('room')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-blue-50 border border-gray-200 hover:border-blue-300 rounded-lg transition group text-left">
                                <div class="w-8 h-8 rounded bg-indigo-100 text-indigo-600 flex items-center justify-center"><i data-lucide="bed-double" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700 group-hover:text-blue-700">Chambre Complète</div>
                                    <div class="text-[10px] text-gray-400">Avec Fenêtre & Porte</div>
                                </div>
                            </button>
                            <button onclick="app.createPresetSpace('bain','petite')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-cyan-50 border border-gray-200 hover:border-cyan-300 rounded-lg transition group text-left">
                                <div class="w-8 h-8 rounded bg-cyan-100 text-cyan-600 flex items-center justify-center"><i data-lucide="sparkle" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700 group-hover:text-cyan-700">Salle d'eau compacte</div>
                                    <div class="text-[10px] text-gray-400">WC + Douche + vasque</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Statistiques</span>
                            <span class="chip">Temps réel</span>
                        </div>
                        <div class="grid grid-cols-2 gap-2 text-center">
                            <div class="bg-white/60 rounded p-2 border border-gray-100">
                                <div id="statRooms" class="text-sm font-bold text-gray-800">0</div>
                                <div class="text-[10px] text-gray-500">Chambres</div>
                            </div>
                            <div class="bg-white/60 rounded p-2 border border-gray-100">
                                <div id="statArea" class="text-sm font-bold text-gray-800">0 m²</div>
                                <div class="text-[10px] text-gray-500">Surface</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Panel Construction -->
                <div data-builder-panel="construction" class="flex flex-col gap-3 hidden">
                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Circulation & volume</span>
                            <span class="chip">Corridors</span>
                        </div>
                        <div class="space-y-2">
                            <button onclick="app.createBlock('corridor')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-teal-50 border border-gray-200 hover:border-teal-300 rounded-lg transition group text-left">
                                <div class="w-8 h-8 rounded bg-teal-100 text-teal-600 flex items-center justify-center"><i data-lucide="arrow-up-down" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700 group-hover:text-teal-700">Couloir</div>
                                    <div class="text-[10px] text-gray-400">Largeur guidée</div>
                                </div>
                            </button>
                            <button onclick="app.createBlock('stairs')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-orange-50 border border-gray-200 hover:border-orange-300 rounded-lg transition group text-left">
                                <div class="w-8 h-8 rounded bg-orange-100 text-orange-600 flex items-center justify-center"><i data-lucide="move-up-right" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700 group-hover:text-orange-700">Escalier</div>
                                    <div class="text-[10px] text-gray-400">Liaison étage</div>
                                </div>
                            </button>
                            <button onclick="app.createBlock('generic')" class="w-full flex items-center gap-3 p-2 bg-white hover:bg-gray-50 border border-gray-200 hover:border-gray-300 rounded-lg transition group text-left">
                                <div class="w-8 h-8 rounded bg-slate-100 text-slate-600 flex items-center justify-center"><i data-lucide="box" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700 group-hover:text-slate-700">Zone libre</div>
                                    <div class="text-[10px] text-gray-400">Volumes personnalisés</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Structures complètes</span>
                            <span class="chip">3 tailles</span>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-[11px]">
                            <button onclick="app.createApartment('petite')" class="p-2 bg-white border border-gray-200 rounded-lg hover:border-sky-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="building-2" size="16" class="text-sky-600"></i>
                                <span class="font-semibold text-gray-700">Appartement S</span>
                                <span class="text-[10px] text-gray-500 text-center">3 pièces côte à côte</span>
                            </button>
                            <button onclick="app.createApartment('moyenne')" class="p-2 bg-white border border-gray-200 rounded-lg hover:border-sky-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="buildings" size="16" class="text-sky-600"></i>
                                <span class="font-semibold text-gray-700">Appartement M</span>
                                <span class="text-[10px] text-gray-500 text-center">Optimisé pour 3 chambres</span>
                            </button>
                            <button onclick="app.createApartment('grande')" class="p-2 bg-white border border-gray-200 rounded-lg hover:border-sky-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="home" size="16" class="text-sky-600"></i>
                                <span class="font-semibold text-gray-700">Appartement L</span>
                                <span class="text-[10px] text-gray-500 text-center">Avec cloisonnement intérieur</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Panel Extérieur -->
                <div data-builder-panel="exterieur" class="flex flex-col gap-3 hidden">
                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Zone extérieure</span>
                            <span class="chip">Paysage</span>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <button onclick="app.createExterior('pelouse')" class="flex items-center gap-2 p-2 bg-white border border-green-200 rounded-lg hover:border-green-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-green-100 text-green-700 flex items-center justify-center"><i data-lucide="sprout" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Pelouse</div>
                                    <div class="text-[10px] text-gray-400">Surface herbeuse</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('arbre')" class="flex items-center gap-2 p-2 bg-white border border-emerald-200 rounded-lg hover:border-emerald-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-emerald-100 text-emerald-700 flex items-center justify-center"><i data-lucide="trees" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Arbre</div>
                                    <div class="text-[10px] text-gray-400">Volume vertical</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('buisson')" class="flex items-center gap-2 p-2 bg-white border border-lime-200 rounded-lg hover:border-lime-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-lime-100 text-lime-700 flex items-center justify-center"><i data-lucide="leaf" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Buisson</div>
                                    <div class="text-[10px] text-gray-400">Masse basse</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('haie')" class="flex items-center gap-2 p-2 bg-white border border-emerald-200 rounded-lg hover:border-emerald-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-emerald-50 text-emerald-700 flex items-center justify-center"><i data-lucide="wall" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Haie</div>
                                    <div class="text-[10px] text-gray-400">Séparation végétale</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('portail')" class="flex items-center gap-2 p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-slate-100 text-slate-700 flex items-center justify-center"><i data-lucide="door-open" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Portail</div>
                                    <div class="text-[10px] text-gray-400">Accès extérieur</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('poubelle')" class="flex items-center gap-2 p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-slate-100 text-slate-700 flex items-center justify-center"><i data-lucide="trash-2" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Poubelle</div>
                                    <div class="text-[10px] text-gray-400">Gestion déchets</div>
                                </div>
                            </button>
                            <button onclick="app.createExterior('grillage')" class="flex items-center gap-2 p-2 bg-white border border-blue-200 rounded-lg hover:border-blue-400 transition text-left">
                                <div class="w-8 h-8 rounded bg-blue-50 text-blue-700 flex items-center justify-center"><i data-lucide="grid" size="16"></i></div>
                                <div class="flex-1">
                                    <div class="text-xs font-bold text-gray-700">Grillage</div>
                                    <div class="text-[10px] text-gray-400">Clôture légère</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="subsection-card p-3 rounded-xl">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-xs font-bold text-gray-600 uppercase">Structures extérieures complètes</span>
                            <span class="chip">3 tailles</span>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-[11px]">
                            <button onclick="app.createExteriorPreset('terrasse','petite')" class="p-2 bg-white border border-amber-200 rounded-lg hover:border-amber-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="sun" size="16" class="text-amber-600"></i>
                                <span class="font-semibold text-gray-700">Terrasse S</span>
                                <span class="text-[10px] text-gray-500 text-center">Bois + végétaux</span>
                            </button>
                            <button onclick="app.createExteriorPreset('terrasse','moyenne')" class="p-2 bg-white border border-amber-200 rounded-lg hover:border-amber-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="sun" size="16" class="text-amber-600"></i>
                                <span class="font-semibold text-gray-700">Terrasse M</span>
                                <span class="text-[10px] text-gray-500 text-center">Avec éclairage</span>
                            </button>
                            <button onclick="app.createExteriorPreset('terrasse','grande')" class="p-2 bg-white border border-amber-200 rounded-lg hover:border-amber-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="sun" size="16" class="text-amber-600"></i>
                                <span class="font-semibold text-gray-700">Terrasse L</span>
                                <span class="text-[10px] text-gray-500 text-center">Zone lounge complète</span>
                            </button>
                            <button onclick="app.createExteriorPreset('parking','petite')" class="p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="car" size="16" class="text-slate-700"></i>
                                <span class="font-semibold text-gray-700">Place parking S</span>
                                <span class="text-[10px] text-gray-500 text-center">Une place</span>
                            </button>
                            <button onclick="app.createExteriorPreset('parking','moyenne')" class="p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="car" size="16" class="text-slate-700"></i>
                                <span class="font-semibold text-gray-700">Place parking M</span>
                                <span class="text-[10px] text-gray-500 text-center">Marquage double</span>
                            </button>
                            <button onclick="app.createExteriorPreset('parking','grande')" class="p-2 bg-white border border-slate-200 rounded-lg hover:border-slate-400 transition flex flex-col items-center gap-1">
                                <i data-lucide="car" size="16" class="text-slate-700"></i>
                                <span class="font-semibold text-gray-700">Place parking L</span>
                                <span class="text-[10px] text-gray-500 text-center">Allée + zone</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL: Properties & Settings -->
    <div class="absolute top-4 right-4 w-80 flex flex-col gap-3 z-10 max-h-[95vh] overflow-y-auto pr-1">
        <div class="glass-panel p-3 rounded-xl">
            <div class="grid grid-cols-4 gap-2" id="inspectorTabs">
                <button data-inspector-tab="essentiel" class="tab-pill active"><i data-lucide="navigation" size="14"></i>Essentiel</button>
                <button data-inspector-tab="apparence" class="tab-pill"><i data-lucide="sparkle" size="14"></i>Apparence</button>
                <button data-inspector-tab="objets" class="tab-pill"><i data-lucide="package" size="14"></i>Objets</button>
                <button data-inspector-tab="fichier" class="tab-pill"><i data-lucide="save" size="14"></i>Fichier</button>
            </div>
        </div>

        <div data-inspector-panel="essentiel" class="flex flex-col gap-3">
            <!-- View Settings -->
            <div class="glass-panel p-3 rounded-xl flex flex-col gap-3">
                <div class="flex items-center justify-between">
                    <span class="panel-title text-xs font-extrabold">Vue et navigation</span>
                    <span class="badge bg-sky-50 text-sky-700 border border-sky-100"><i data-lucide="compass" size="14"></i>Caméra</span>
                </div>
                <div class="flex gap-1">
                <button id="viewFloor" class="flex-1 py-2 text-xs font-bold rounded-lg transition flex items-center justify-center gap-2 btn-tool active">
                    <i data-lucide="layers" size="14"></i> Étage
                </button>
                <button id="viewGlobal" class="flex-1 py-2 text-xs font-bold rounded-lg transition flex items-center justify-center gap-2 btn-tool bg-white/50 hover:bg-white">
                    <i data-lucide="box-select" size="14"></i> Global
                </button>
                </div>
                <div class="grid grid-cols-2 gap-2 text-[11px] text-slate-500">
                    <div class="soft-card rounded-lg p-2 flex items-center gap-2"><i data-lucide="eye" size="14"></i><span id="viewHint">Exploration étage en cours</span></div>
                    <div class="soft-card rounded-lg p-2 flex items-center gap-2"><i data-lucide="ruler" size="14"></i><span>Nappes alignées sur la grille 0.5m</span></div>
                </div>
            </div>

            <!-- Tools Mode -->
            <div class="glass-panel p-3 rounded-xl">
                <div class="flex gap-1 bg-gray-100/50 p-1 rounded-lg">
                    <button id="toolTranslate" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Déplacer (W)">
                        <i data-lucide="move" size="16"></i>
                    </button>
                    <button id="toolRotate" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Pivoter (E)">
                        <i data-lucide="rotate-cw" size="16"></i>
                    </button>
                    <button id="toolScale" class="flex-1 py-1.5 rounded text-gray-600 hover:bg-white shadow-sm transition flex justify-center" title="Redimensionner (R)">
                        <i data-lucide="maximize" size="16"></i>
                    </button>
                </div>
                <div class="mt-2 grid grid-cols-3 gap-1 text-[10px] text-slate-500">
                    <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="wand-2" size="12"></i><span>Aligner</span></div>
                    <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="sprout" size="12"></i><span>Snapping</span></div>
                    <div class="soft-card rounded p-2 flex items-center gap-1"><i data-lucide="shield" size="12"></i><span>Confort</span></div>
                </div>
            </div>
        </div>

        <div data-inspector-panel="apparence" class="flex flex-col gap-3 hidden">
            <!-- Selection Properties (Conditional) -->
            <div id="propPanel" class="glass-panel p-4 rounded-xl transition-all duration-300 opacity-50 pointer-events-none scale-95 origin-top">
                <div class="flex justify-between items-start mb-3">
                    <div>
                        <h2 id="propTitle" class="text-xs font-bold text-blue-600 uppercase tracking-wide">Propriétés</h2>
                        <p class="text-[11px] text-slate-500">Nom, rotation guidée, couleurs et étiquettes.</p>
                    </div>
                    <button id="deleteBtn" class="text-red-400 hover:text-red-600 transition" title="Supprimer"><i data-lucide="trash-2" size="16"></i></button>
                </div>

                <div class="grid grid-cols-2 gap-2 mb-4 text-[11px] text-slate-600">
                    <div class="soft-card rounded-lg p-2 flex flex-col gap-1">
                        <span class="subtle-label">Cible active</span>
                        <span id="colorTargetBadge" class="badge bg-indigo-50 text-indigo-700 border border-indigo-100"><i data-lucide="paint-bucket" size="14"></i>Murs</span>
                    </div>
                    <div class="soft-card rounded-lg p-2 flex flex-col gap-1">
                        <span class="subtle-label">Niveau</span>
                        <span id="floorContextBadge" class="badge bg-emerald-50 text-emerald-700 border border-emerald-100"><i data-lucide="map-pin" size="14"></i>RDC</span>
                    </div>
                </div>

                <!-- Name Input -->
                <div class="mb-4">
                    <label class="block text-[10px] font-bold text-gray-500 mb-1">IDENTIFIANT / NOM</label>
                    <div class="flex gap-1">
                        <input type="text" id="propName" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-sm focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition">
                        <button id="propNameBtn" class="px-2 bg-blue-50 text-blue-600 rounded border border-blue-100 hover:bg-blue-100"><i data-lucide="check" size="14"></i></button>
                    </div>
                </div>

                <!-- Rotation Presets -->
                <div id="rotationSection" class="mb-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="block text-[10px] font-bold text-gray-500">ROTATIONS GUIDÉES</span>
                        <div class="flex items-center gap-1">
                            <label class="text-[10px] text-slate-500">Axe</label>
                            <select id="rotationAxisSelect" class="text-xs border border-gray-200 rounded px-1 py-0.5 bg-white">
                                <option value="y">Y</option>
                                <option value="x">X</option>
                                <option value="z">Z</option>
                            </select>
                            <label class="text-[10px] text-slate-500">Angle</label>
                            <select id="rotationAngleSelect" class="text-xs border border-gray-200 rounded px-1 py-0.5 bg-white">
                                <option value="15">15°</option>
                                <option value="30">30°</option>
                                <option value="45" selected>45°</option>
                                <option value="90">90°</option>
                                <option value="180">180°</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="rotateCounter" class="py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                            <i data-lucide="rotate-ccw" size="14"></i>Rotation -
                        </button>
                        <button id="rotateClockwise" class="py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                            <i data-lucide="rotate-cw" size="14"></i>Rotation +
                        </button>
                    </div>
                </div>

                <!-- Color Picker (Hidden for furniture if needed) -->
                <div id="colorSection" class="mb-4">
                    <div class="flex text-[10px] font-bold text-gray-500 mb-2 gap-2 bg-gray-50 p-1 rounded">
                        <button id="targetBlock" class="flex-1 py-1 rounded text-center transition bg-white shadow-sm text-gray-800">Murs</button>
                        <button id="targetLabel" class="flex-1 py-1 rounded text-center transition hover:bg-white text-gray-400">Étiquette</button>
                    </div>
                    <div id="colorGrid" class="grid grid-cols-6 gap-2">
                        <!-- Generated via JS -->
                    </div>
                </div>

                <!-- Opacity Control -->
                <div id="opacitySection" class="mb-4">
                    <div class="flex items-center justify-between mb-1">
                        <span class="block text-[10px] font-bold text-gray-500">TRANSPARENCE</span>
                        <span id="opacityValue" class="text-[10px] text-gray-500 font-semibold">100%</span>
                    </div>
                    <div id="opacityTargetGroup" class="flex text-[10px] font-bold text-gray-500 mb-2 gap-2 bg-gray-50 p-1 rounded hidden">
                        <button id="opacityTargetWalls" class="flex-1 py-1 rounded text-center transition bg-white shadow-sm text-gray-800">Chambre</button>
                        <button id="opacityTargetFurniture" class="flex-1 py-1 rounded text-center transition hover:bg-white text-gray-400">Objets</button>
                    </div>
                    <input id="opacityInput" type="range" min="0.05" max="1" step="0.05" value="1" class="w-full accent-blue-500">
                    <div class="text-[10px] text-slate-500 mt-1">Ajuste la visibilité de l'objet ou structure sélectionné(e).</div>
                </div>

                <!-- Wall Manager -->
                <div id="wallSection" class="mb-4 space-y-2 hidden">
                    <div class="flex items-center justify-between">
                        <label class="block text-[10px] font-bold text-gray-500">MURS DE LA CHAMBRE</label>
                        <span class="text-[10px] text-gray-400">Ouverture guidée</span>
                    </div>
                    <div class="flex gap-2 items-center">
                        <select id="wallSelector" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500"></select>
                        <button id="removeWallBtn" class="px-2 bg-red-50 text-red-600 border border-red-200 rounded text-xs font-bold hover:bg-red-100 disabled:opacity-50 disabled:cursor-not-allowed">Suppr.</button>
                    </div>
                    <p class="text-[10px] text-slate-500">Choisissez un mur de la chambre sélectionnée pour le retirer.</p>
                </div>

                <!-- Presets Size -->
                <div id="sizeSection" class="mb-2">
                     <label class="block text-[10px] font-bold text-gray-500 mb-1">TAILLE RAPIDE</label>
                     <div class="flex gap-1">
                         <button onclick="app.resizeSelection('S')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">S</button>
                         <button onclick="app.resizeSelection('M')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">M</button>
                         <button onclick="app.resizeSelection('L')" class="flex-1 py-1 bg-white border border-gray-200 rounded text-xs font-bold text-gray-600 hover:bg-gray-50">L</button>
                     </div>
                     <div id="structureDimensionsSection" class="mt-2 grid grid-cols-3 gap-2 text-[10px] text-gray-600">
                         <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Longueur
                             <input id="structureLengthInput" type="number" step="0.1" min="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                         </label>
                         <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Largeur
                             <input id="structureWidthInput" type="number" step="0.1" min="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                         </label>
                         <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Hauteur
                             <input id="structureHeightInput" type="number" step="0.1" min="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                         </label>
                     </div>
                </div>

                <!-- Label Controls -->
                <div id="labelSection" class="mb-4 space-y-2">
                    <div class="flex items-center justify-between">
                        <span class="block text-[10px] font-bold text-gray-500">ÉTIQUETTE</span>
                        <div class="flex gap-1">
                            <button id="toggleDoorLabelBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Porte</button>
                            <button id="toggleLabelBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Afficher</button>
                            <button id="toggleAllLabelsBtn" class="px-2 py-1 bg-white border border-gray-200 rounded text-[10px] font-bold text-gray-600 hover:bg-gray-50">Tout</button>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-2 text-[10px] text-gray-600">
                        <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                            Taille
                            <input id="labelSizeInput" type="range" min="0.5" max="3" step="0.1" class="w-full accent-blue-500">
                        </label>
                        <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                            Couleur texte
                            <input id="labelTextColorInput" type="color" class="w-full h-8 border border-gray-200 rounded" value="#ffffff">
                        </label>
                    </div>
                    <div class="grid grid-cols-3 gap-2 text-[10px] text-gray-600">
                        <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                            X
                            <input id="labelPosX" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                        </label>
                        <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                            Y
                            <input id="labelPosY" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                        </label>
                        <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">
                            Z
                            <input id="labelPosZ" type="number" step="0.1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div data-inspector-panel="objets" class="flex flex-col gap-3 hidden">
            <div id="furnitureTransformSection" class="glass-panel p-3 rounded-xl mb-1 space-y-2 hidden">
                <label class="block text-[10px] font-bold text-gray-500">DIMENSIONS MOBILIER</label>
                <div class="grid grid-cols-3 gap-2 text-[10px] text-gray-600">
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Largeur
                        <input id="furnScaleX" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Hauteur
                        <input id="furnScaleY" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                    <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1">Profondeur
                        <input id="furnScaleZ" type="number" step="0.1" min="0.2" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                    </label>
                </div>
                <label class="flex flex-col bg-white border border-gray-200 rounded p-2 gap-1 text-[10px] text-gray-600">Orientation (Y°)
                    <input id="furnRotationY" type="number" step="1" class="w-full text-xs border border-gray-200 rounded px-1 py-0.5" />
                </label>
            </div>

            <div id="furnitureSection" class="glass-panel p-3 rounded-xl space-y-2">
                  <div class="flex items-center justify-between">
                      <label class="block text-[10px] font-bold text-gray-500">OBJETS DE LA CHAMBRE</label>
                      <span class="chip">Bibliothèque étendue</span>
                  </div>
                  <div class="flex gap-2">
                      <select id="furnitureSelector" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500">
                          <!-- options via JS -->
                    </select>
                    <button id="addFurnitureBtn" class="px-2 bg-blue-600 text-white rounded text-xs font-bold hover:bg-blue-700">Ajouter</button>
                    <button id="removeFurnitureBtn" class="px-2 bg-red-50 text-red-600 border border-red-200 rounded text-xs font-bold hover:bg-red-100">Suppr.</button>
                  </div>
            </div>

            <div class="glass-panel p-3 rounded-xl space-y-2">
                  <div class="flex items-center justify-between">
                      <label class="block text-[10px] font-bold text-gray-500">CÂBLAGE DISJONCTEURS</label>
                      <span class="badge bg-amber-50 text-amber-700 border border-amber-100"><i data-lucide="zap" size="14"></i>Flux</span>
                  </div>
                  <button id="toggleCablesBtn" class="w-full py-2 bg-white border border-gray-200 rounded text-xs font-bold text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2">
                      <i data-lucide="eye" size="14"></i>Masquer le câblage
                  </button>
                  <div id="breakerSection" class="space-y-2 hidden">
                      <div class="flex items-center justify-between">
                          <span class="block text-[10px] font-bold text-gray-500">BOÎTIER DISJONCTEURS</span>
                          <span class="text-[10px] text-emerald-600 font-semibold flex items-center gap-1"><i data-lucide="circuit-board" size="14"></i>Chambres alimentées</span>
                      </div>
                      <div class="bg-white border border-gray-200 rounded-lg p-2 space-y-2 text-[10px] text-gray-700">
                          <div class="flex items-center justify-between">
                              <span class="text-gray-500">Sélectionner les chambres</span>
                              <button id="breakerSelectAll" class="px-2 py-1 bg-emerald-50 text-emerald-700 border border-emerald-100 rounded hover:bg-emerald-100">Tout</button>
                          </div>
                          <div id="breakerRoomsList" class="max-h-32 overflow-y-auto space-y-1"></div>
                      </div>
                  </div>
            </div>

            <div class="glass-panel p-3 rounded-xl space-y-2">
                  <div class="flex items-center justify-between">
                      <label class="block text-[10px] font-bold text-gray-500">Dupliquer vers un étage</label>
                      <label class="flex items-center gap-1 text-[10px] text-gray-600 font-semibold">
                          <input id="multiSelectToggle" type="checkbox" class="accent-emerald-600" />
                          Sélection multiple
                      </label>
                  </div>
                  <div class="flex gap-2 items-center">
                      <input id="duplicateFloorTarget" type="number" min="0" class="flex-1 bg-white border border-gray-200 rounded px-2 py-1 text-xs focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500" />
                      <span class="text-[10px] text-gray-400">RDC=0</span>
                  </div>
                  <div id="multiSelectHint" class="text-[10px] text-gray-500 flex items-center gap-1">
                      <i data-lucide="list" size="12"></i><span>Sélection classique</span>
                  </div>
                  <button id="duplicateBtn" class="w-full mt-1 py-2 bg-yellow-50 text-yellow-700 text-xs font-bold rounded border border-yellow-200 hover:bg-yellow-100 flex items-center justify-center gap-2">
                      <i data-lucide="copy" size="14"></i> Dupliquer Objet
                  </button>
            </div>
        </div>

        <div data-inspector-panel="fichier" class="flex flex-col gap-3 hidden">
            <!-- Footer Actions -->
            <div class="glass-panel p-3 rounded-xl">
                 <div class="grid grid-cols-2 gap-2">
                     <button id="saveBtn" class="py-2 bg-green-600 text-white text-xs font-bold rounded hover:bg-green-700 shadow-lg shadow-green-900/20 transition flex items-center justify-center gap-1">
                         <i data-lucide="save" size="14"></i> Sauver
                     </button>
                     <button id="loadBtn" class="py-2 bg-gray-600 text-white text-xs font-bold rounded hover:bg-gray-700 shadow-lg shadow-gray-900/20 transition flex items-center justify-center gap-1">
                         <i data-lucide="folder-open" size="14"></i> Ouvrir
                     </button>
                 </div>
                 <button id="resetBtn" class="w-full mt-2 text-[10px] text-gray-400 hover:text-red-500 underline decoration-dotted text-center">Réinitialiser la scène</button>
            </div>
        </div>
    </div>

    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- APP LOGIC -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            gridSize: 0.5,
            floorHeight: 3.5,
            floorGap: 0.5,
            colors: [
                '#6366f1', '#3b82f6', '#0ea5e9', '#14b8a6',
                '#22c55e', '#84cc16', '#eab308', '#f97316', 
                '#ef4444', '#a855f7', '#d946ef', '#ec4899', 
                '#64748b', '#94a3b8', '#cbd5e1', '#f1f5f9', 
                '#ffffff', '#0f172a'
            ],
            defaultLabelColor: '#1e293b',
            defaultTextColor: '#ffffff',
            defaultLabelScale: 1.2,
            defaultLabelOffset: { x: 0, y: 4, z: 0 },
            roomWidth: 4,
            roomDepth: 6
        };

        // --- FACTORY A MEUBLES ---
        const FurnitureFactory = {
            bed: () => {
                const group = new THREE.Group();
                const bedGeo = new THREE.BoxGeometry(1.6, 0.5, 2);
                const bedMat = new THREE.MeshStandardMaterial({ color: '#ffffff' });
                const bed = new THREE.Mesh(bedGeo, bedMat);
                bed.position.y = 0.25;
                bed.castShadow = true; bed.receiveShadow = true;
                
                const pillowGeo = new THREE.BoxGeometry(0.6, 0.15, 0.4);
                const pMat = new THREE.MeshStandardMaterial({color: '#cbd5e1'});
                const p1 = new THREE.Mesh(pillowGeo, pMat); p1.position.set(-0.4, 0.6, -0.7);
                const p2 = new THREE.Mesh(pillowGeo, pMat); p2.position.set(0.4, 0.6, -0.7);
                
                group.add(bed, p1, p2);
                group.userData = { isFurniture: true, type: 'bed', name: 'Lit', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            shower: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 1.2), new THREE.MeshStandardMaterial({color: '#ffffff'}));
                base.position.y = 0.05;
                const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.1, 2.2, 1.1), new THREE.MeshStandardMaterial({color: '#0ea5e9', transparent: true, opacity: 0.3}));
                cabin.position.y = 1.15;
                group.add(base, cabin);
                group.userData = { isFurniture: true, type: 'shower', name: 'Douche', dims: {x:1.2, z:1.2}, defaultY: 0 };
                return group;
            },
            wardrobe: () => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2.4, 0.6), new THREE.MeshStandardMaterial({ color: '#854d0e' }));
                mesh.position.y = 1.2;
                mesh.castShadow = true;
                mesh.userData = { isFurniture: true, type: 'wardrobe', name: 'Armoire', dims: {x:0.8, z:0.6}, defaultY: 1.2 };
                return mesh;
            },
            desk: () => {
                const group = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.1, 1.5), new THREE.MeshStandardMaterial({color: '#475569'}));
                top.position.y = 0.8;
                group.add(top);
                group.userData = { isFurniture: true, type: 'desk', name: 'Bureau', dims: {x:0.6, z:1.5}, defaultY: 0 };
                return group;
            },
            chair: () => {
                const group = new THREE.Group();
                const seat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.4), new THREE.MeshStandardMaterial({color: '#ef4444'}));
                seat.position.y = 0.5;
                const back = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.5, 0.4), new THREE.MeshStandardMaterial({color: '#ef4444'}));
                back.position.set(0.15, 0.75, 0);
                group.add(seat, back);
                group.userData = { isFurniture: true, type: 'chair', name: 'Chaise', dims: {x:0.4, z:0.4}, defaultY: 0 };
                return group;
            },
            table: () => {
                const group = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.1, 0.8), new THREE.MeshStandardMaterial({color: '#cbd5e1'}));
                top.position.y = 0.8;
                const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.8);
                const legMat = new THREE.MeshStandardMaterial({color: '#475569'});
                const positions = [
                    [-0.6, 0.4], [0.6, 0.4], [-0.6, -0.4], [0.6, -0.4]
                ];
                positions.forEach(p => {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(p[0], 0.4, p[1]);
                    group.add(leg);
                });
                group.add(top);
                group.userData = { isFurniture: true, type: 'table', name: 'Table', dims: {x:1.4, z:0.8}, defaultY: 0 };
                return group;
            },
            tv: () => {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 1.2), new THREE.MeshStandardMaterial({color: '#000000', metalness: 0.8}));
                mesh.position.y = 1.5;
                mesh.userData = { isFurniture: true, type: 'tv', name: 'TV', dims: {x:0.1, z:1.2}, defaultY: 1.5 };
                return mesh;
            },
            toilet: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.4, 0.5, 20), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                base.position.y = 0.25;
                const tank = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.2), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                tank.position.set(0, 0.75, -0.15);
                const seat = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.1, 20), new THREE.MeshStandardMaterial({color: '#f8fafc'}));
                seat.position.y = 0.5;
                group.add(base, tank, seat);
                group.userData = { isFurniture: true, type: 'toilet', name: 'WC', dims: {x:0.8, z:0.8}, defaultY: 0 };
                return group;
            },
            sink: () => {
                const group = new THREE.Group();
                const column = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.7, 16), new THREE.MeshStandardMaterial({color: '#94a3b8'}));
                column.position.y = 0.35;
                const bowl = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.4, 0.25, 20), new THREE.MeshStandardMaterial({color: '#e5e7eb'}));
                bowl.position.y = 0.75;
                const tap = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.15, 0.3), new THREE.MeshStandardMaterial({color: '#1e293b'}));
                tap.position.set(0, 0.95, -0.1);
                group.add(column, bowl, tap);
                group.userData = { isFurniture: true, type: 'sink', name: 'Évier', dims: {x:0.9, z:0.9}, defaultY: 0 };
                return group;
            },
            bathtub: () => {
                const group = new THREE.Group();
                const tub = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 0.8), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                tub.position.y = 0.3;
                const water = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.3, 0.6), new THREE.MeshStandardMaterial({color: '#bfdbfe', transparent: true, opacity: 0.6}));
                water.position.y = 0.45;
                group.add(tub, water);
                group.userData = { isFurniture: true, type: 'bathtub', name: 'Baignoire', dims: {x:1.6, z:0.8}, defaultY: 0 };
                return group;
            },
            crib: () => {
                const group = new THREE.Group();
                const base = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.1, 1.2), new THREE.MeshStandardMaterial({color: '#fef08a'}));
                base.position.y = 0.2;
                const sideMat = new THREE.MeshStandardMaterial({color: '#f59e0b'});
                const railGeo = new THREE.BoxGeometry(0.05, 0.6, 1.2);
                const rail1 = new THREE.Mesh(railGeo, sideMat); rail1.position.set(-0.35, 0.55, 0);
                const rail2 = new THREE.Mesh(railGeo, sideMat); rail2.position.set(0.35, 0.55, 0);
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.05), sideMat); head.position.set(0, 0.55, 0.6);
                const foot = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.05), sideMat); foot.position.set(0, 0.55, -0.6);
                group.add(base, rail1, rail2, head, foot);
                group.userData = { isFurniture: true, type: 'crib', name: 'Lit bébé', dims: {x:0.7, z:1.2}, defaultY: 0 };
                return group;
            },
            singleBed: () => {
                const group = FurnitureFactory.bed();
                group.scale.set(0.7, 1, 0.75);
                group.userData = { isFurniture: true, type: 'singleBed', name: 'Lit simple', dims: {x:1.1, z:1.6}, defaultY: 0 };
                return group;
            },
            doubleBed: () => {
                const group = FurnitureFactory.bed();
                group.userData = { isFurniture: true, type: 'doubleBed', name: 'Lit double', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            bunkBed: () => {
                const group = new THREE.Group();
                const lower = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.5, 2), new THREE.MeshStandardMaterial({color: '#e2e8f0'}));
                lower.position.y = 0.25;
                const upper = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 1.6), new THREE.MeshStandardMaterial({color: '#cbd5e1'}));
                upper.position.set(0, 1.5, 0);
                const ladder = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.6, 0.4), new THREE.MeshStandardMaterial({color: '#b45309'}));
                ladder.position.set(0.9, 0.8, 0.9);
                group.add(lower, upper, ladder);
                group.userData = { isFurniture: true, type: 'bunkBed', name: 'Lit superposé', dims: {x:1.6, z:2}, defaultY: 0 };
                return group;
            },
            door: () => {
                const group = new THREE.Group();
                const h = CONFIG.floorHeight;
                // Cadre
                const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(1.2, h, 0.3), new THREE.MeshStandardMaterial({color: '#475569'}));
                doorFrame.position.y = h/2;
                // Porte
                const door = new THREE.Mesh(new THREE.BoxGeometry(1.0, h*0.85, 0.35), new THREE.MeshStandardMaterial({color: '#854d0e'}));
                door.position.set(0, h/2, 0); 
                
                group.add(doorFrame, door);
                group.userData = { isFurniture: true, type: 'door', name: 'Porte', isWallMounted: true, defaultY: 0 };
                return group;
            },
              window: () => {
                  const group = new THREE.Group();
                  const h = CONFIG.floorHeight;
                  // Cadre
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.4, 0.3), new THREE.MeshStandardMaterial({color: '#475569'}));
                // Vitre
                const glass = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.2, 0.32), new THREE.MeshStandardMaterial({color: '#bae6fd', transparent: true, opacity: 0.5}));

                  group.add(frame, glass);
                  // Y par défaut à 1.5m du sol (centre de la fenêtre)
                  group.userData = { isFurniture: true, type: 'window', name: 'Fenêtre', isWallMounted: true, defaultY: 1.5 };
                  return group;
              },
              balcony: () => {
                  const group = new THREE.Group();
                  const platform = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 1.2), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  platform.position.y = 0.1;
                  const railMat = new THREE.MeshStandardMaterial({ color: '#111827' });
                  const rail = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 0.1), railMat);
                  rail.position.set(0, 0.9, 0.55);
                  group.add(platform, rail);
                  group.userData = { isFurniture: true, type: 'balcony', name: 'Balcon', isWallMounted: true, defaultY: 0, wallOffset: 0.8, dims: {x:2, z:1.2} };
                  return group;
              },
              frenchDoor: () => {
                  const group = new THREE.Group();
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.8, 2.6, 0.25), new THREE.MeshStandardMaterial({ color: '#475569' }));
                  const glass = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.4, 0.2), new THREE.MeshStandardMaterial({ color: '#bae6fd', transparent: true, opacity: 0.5 }));
                  glass.position.z = 0.02;
                  group.add(frame, glass);
                  group.userData = { isFurniture: true, type: 'frenchDoor', name: 'Porte-fenêtre', isWallMounted: true, defaultY: 0, dims: {x:1.8, z:0.3} };
                  return group;
              },
              innerWall: () => {
                  const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, CONFIG.floorHeight, 3), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                  mesh.position.y = CONFIG.floorHeight / 2;
                  mesh.userData = { isFurniture: true, type: 'innerWall', name: 'Mur intérieur', dims: {x:0.2, z:3}, defaultY: mesh.position.y };
                  return mesh;
              },
                wcDoor: () => {
                    const group = new THREE.Group();
                    const h = CONFIG.floorHeight * 0.9;
                    const frame = new THREE.Mesh(new THREE.BoxGeometry(0.9, h, 0.25), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                    frame.position.y = h / 2;
                    const leaf = new THREE.Mesh(new THREE.BoxGeometry(0.7, h * 0.9, 0.3), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                    leaf.position.set(0, h / 2, 0);
                    group.add(frame, leaf);
                    group.userData = { isFurniture: true, type: 'wcDoor', name: 'Porte WC', isWallMounted: false, defaultY: 0, dims: {x:0.9, z:0.3} };
                    return group;
                },
              mirror: () => {
                  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.08), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const glass = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.4, 0.04), new THREE.MeshStandardMaterial({ color: '#e2e8f0', metalness: 0.8, roughness: 0.1, envMapIntensity: 0.9 }));
                  glass.position.z = 0.03;
                  const group = new THREE.Group();
                  group.add(frame, glass);
                  group.userData = { isFurniture: true, type: 'mirror', name: 'Miroir', isWallMounted: true, defaultY: 1.2, dims: {x:1.2, z:0.1} };
                  return group;
              },
              wallLamp: () => {
                  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.2, 12), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const shade = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16, 0, Math.PI), new THREE.MeshStandardMaterial({ color: '#fde68a', emissive: '#fbbf24', emissiveIntensity: 0.8 }));
                  shade.position.y = 0.25;
                  const group = new THREE.Group();
                  group.add(base, shade);
                  group.userData = { isFurniture: true, type: 'wallLamp', name: 'Lampe murale', isWallMounted: true, defaultY: 1.6, dims: {x:0.3, z:0.3} };
                  return group;
              },
              wallNeon: () => {
                  const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.6, 12), new THREE.MeshStandardMaterial({ color: '#a5f3fc', emissive: '#22d3ee', emissiveIntensity: 1.1 }));
                  tube.rotation.z = Math.PI / 2;
                  const mount = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.12, 0.18), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const group = new THREE.Group();
                  group.add(mount, tube);
                  group.userData = { isFurniture: true, type: 'wallNeon', name: 'Néon mural', isWallMounted: true, defaultY: 1.8, dims: {x:1.8, z:0.2} };
                  return group;
              },
              heater: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.25), new THREE.MeshStandardMaterial({ color: '#e5e7eb' }));
                  body.position.y = 0.35;
                  const grille = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 0.05), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  grille.position.set(0, 0.65, 0.13);
                  const group = new THREE.Group();
                  group.add(body, grille);
                  group.userData = { isFurniture: true, type: 'heater', name: 'Chauffage', isWallMounted: true, defaultY: 0.35, dims: {x:1.2, z:0.25} };
                  return group;
              },
              breakerBox: () => {
                  const box = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 0.3), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  const door = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.95, 0.05), new THREE.MeshStandardMaterial({ color: '#1f2937', opacity: 0.7, transparent: true }));
                  door.position.z = 0.15;
                  const switches = new THREE.Group();
                  const colors = ['#22c55e', '#f97316', '#38bdf8', '#eab308'];
                  colors.forEach((c, i) => {
                      const sw = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.12), new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 0.3 }));
                      sw.position.set(-0.3 + i * 0.2, 0.15, 0.16);
                      switches.add(sw);
                  });
                  const group = new THREE.Group();
                  group.add(box, door, switches);
                  group.userData = { isFurniture: true, type: 'breakerBox', name: 'Boîtier disjoncteurs', isWallMounted: true, defaultY: 1.3, dims: {x:0.8, z:0.3}, feeds: [], isBreaker: true };
                  return group;
              },
              washer: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1, 0.7), new THREE.MeshStandardMaterial({ color: '#e2e8f0' }));
                  body.position.y = 0.5;
                  const door = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.08, 24), new THREE.MeshStandardMaterial({ color: '#38bdf8', metalness: 0.4, roughness: 0.2 }));
                  door.rotation.x = Math.PI / 2;
                  door.position.set(0, 0.6, 0.35);
                  const group = new THREE.Group();
                  group.add(body, door);
                  group.userData = { isFurniture: true, type: 'washer', name: 'Lave-linge', defaultY: 0, dims: {x:0.7, z:0.7} };
                  return group;
              },
              dryer: () => {
                  const mesh = FurnitureFactory.washer();
                  mesh.userData = { ...mesh.userData, type: 'dryer', name: 'Sèche-linge' };
                  mesh.children[1].material = new THREE.MeshStandardMaterial({ color: '#fde68a', metalness: 0.2, roughness: 0.4 });
                  return mesh;
              },
              fridge: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.9, 0.8), new THREE.MeshStandardMaterial({ color: '#f8fafc' }));
                  body.position.y = 0.95;
                  const handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.6, 0.04), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  handle.position.set(0.45, 1.0, 0.42);
                  const group = new THREE.Group();
                  group.add(body, handle);
                  group.userData = { isFurniture: true, type: 'fridge', name: 'Réfrigérateur', defaultY: 0, dims: {x:0.9, z:0.8} };
                  return group;
              },
              fireExtinguisher: () => {
                  const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.6, 16), new THREE.MeshStandardMaterial({ color: '#ef4444' }));
                  tank.position.y = 0.3;
                  const head = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.16), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  head.position.y = 0.65;
                  const group = new THREE.Group();
                  group.add(tank, head);
                  group.userData = { isFurniture: true, type: 'fireExtinguisher', name: 'Extincteur incendie', defaultY: 0, dims: {x:0.2, z:0.2} };
                  return group;
              },
              smokeDetector: () => {
                  const disk = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.22, 0.08, 24), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                  disk.rotation.x = Math.PI / 2;
                  disk.position.y = CONFIG.floorHeight - 0.05;
                  disk.userData = { isFurniture: true, type: 'smokeDetector', name: 'Détecteur de fumée', defaultY: disk.position.y };
                  return disk;
              },
              kitchenTable: () => {
                  const top = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.08, 0.9), new THREE.MeshStandardMaterial({ color: '#fcd34d' }));
                  top.position.y = 0.85;
                  const legs = new THREE.Group();
                  const legGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.9, 12);
                  const legMat = new THREE.MeshStandardMaterial({ color: '#78350f' });
                  [[-0.7, 0.45], [0.7, 0.45], [-0.7, -0.45], [0.7, -0.45]].forEach(([x,z]) => {
                      const leg = new THREE.Mesh(legGeo, legMat);
                      leg.position.set(x, 0.45, z);
                      legs.add(leg);
                  });
                  const group = new THREE.Group();
                  group.add(top, legs);
                  group.userData = { isFurniture: true, type: 'kitchenTable', name: 'Table de cuisine', defaultY: 0, dims: {x:1.6, z:0.9} };
                  return group;
              },
              hood: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.3, 0.6), new THREE.MeshStandardMaterial({ color: '#334155', metalness: 0.6 }));
                  body.position.y = 2.0;
                  body.userData = { isFurniture: true, type: 'hood', name: 'Hotte de cuisine', isWallMounted: true, defaultY: body.position.y, dims: {x:1.2, z:0.6} };
                  return body;
              },
              cooktop: () => {
                  const plate = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.08, 0.8), new THREE.MeshStandardMaterial({ color: '#0f172a', metalness: 0.3 }));
                  plate.position.y = 0.85;
                  plate.userData = { isFurniture: true, type: 'cooktop', name: 'Plaque chauffante', defaultY: 0.85, dims: {x:1, z:0.8} };
                  return plate;
              },
              microwave: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.5), new THREE.MeshStandardMaterial({ color: '#e5e7eb' }));
                  body.position.y = 0.2;
                  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.02), new THREE.MeshStandardMaterial({ color: '#0ea5e9' }));
                  screen.position.set(-0.05, 0.22, 0.26);
                  const group = new THREE.Group();
                  group.add(body, screen);
                  group.userData = { isFurniture: true, type: 'microwave', name: 'Micro-onde', defaultY: 0, dims: {x:0.7, z:0.5} };
                  return group;
              },
              dumpster: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1, 1), new THREE.MeshStandardMaterial({ color: '#1f2937' }));
                  body.position.y = 0.5;
                  const lid = new THREE.Mesh(new THREE.BoxGeometry(1.42, 0.12, 1.02), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  lid.position.y = 1.05;
                  const group = new THREE.Group();
                  group.add(body, lid);
                  group.userData = { isFurniture: true, type: 'dumpster', name: 'Benne à ordures', defaultY: 0, dims: {x:1.4, z:1} };
                  return group;
              },
              camera: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.25), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  body.position.set(0, 1.8, 0);
                  const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.12, 12), new THREE.MeshStandardMaterial({ color: '#38bdf8' }));
                  lens.rotation.x = Math.PI / 2;
                  lens.position.set(0, 1.8, 0.16);
                  const group = new THREE.Group();
                  group.add(body, lens);
                  group.userData = { isFurniture: true, type: 'camera', name: 'Caméra de surveillance', isWallMounted: true, defaultY: 1.8, dims: {x:0.4, z:0.25} };
                  return group;
              },
              fireAlarm: () => {
                  const mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.12, 16), new THREE.MeshStandardMaterial({ color: '#ef4444' }));
                  mesh.rotation.x = Math.PI / 2;
                  mesh.position.y = 2.2;
                  mesh.userData = { isFurniture: true, type: 'fireAlarm', name: 'Alarme incendie', defaultY: mesh.position.y, dims: {x:0.2, z:0.2} };
                  return mesh;
              },
              fireCabinet: () => {
                  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.6, 0.35), new THREE.MeshStandardMaterial({ color: '#b91c1c' }));
                  body.position.y = 0.8;
                  const glass = new THREE.Mesh(new THREE.BoxGeometry(0.75, 1.3, 0.05), new THREE.MeshStandardMaterial({ color: '#fca5a5', transparent: true, opacity: 0.6 }));
                  glass.position.set(0, 0.8, 0.18);
                  const group = new THREE.Group();
                  group.add(body, glass);
                  group.userData = { isFurniture: true, type: 'fireCabinet', name: 'Armoire alarme incendie', isWallMounted: true, defaultY: 0, dims: {x:0.9, z:0.35} };
                  return group;
              },
              mainBreaker: () => {
                  const board = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.6, 0.35), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                  board.position.y = 0.8;
                  const indicator = new THREE.Mesh(new THREE.BoxGeometry(1, 0.2, 0.05), new THREE.MeshStandardMaterial({ color: '#22c55e', emissive: '#22c55e', emissiveIntensity: 0.5 }));
                  indicator.position.set(0, 1.4, 0.2);
                  const group = new THREE.Group();
                  group.add(board, indicator);
                  group.userData = { isFurniture: true, type: 'mainBreaker', name: 'Tableau électrique principal', isWallMounted: true, defaultY: 0, dims: {x:1.2, z:0.35} };
                  return group;
              },
              waterHeater: () => {
                  const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.6, 16), new THREE.MeshStandardMaterial({ color: '#e2e8f0' }));
                  cyl.position.y = 0.8;
                  const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.52, 0.52, 0.1, 16), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                  cap.position.y = 1.55;
                  const group = new THREE.Group();
                  group.add(cyl, cap);
                  group.userData = { isFurniture: true, type: 'waterHeater', name: "Ballon d'eau chaude", defaultY: 0, dims: {x:1, z:1} };
                  return group;
              }
          };

        const ExteriorFactory = {
            pelouse: () => {
                const geo = new THREE.BoxGeometry(6, 0.05, 6);
                const mat = new THREE.MeshStandardMaterial({ color: '#22c55e', roughness: 0.8 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.receiveShadow = true;
                mesh.userData = { type: 'Exterieur', element: 'pelouse', name: 'Pelouse' };
                return mesh;
            },
            arbre: () => {
                const group = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 2, 8), new THREE.MeshStandardMaterial({ color: '#92400e' }));
                trunk.position.y = 1;
                const foliage = new THREE.Mesh(new THREE.ConeGeometry(1.2, 2.4, 8), new THREE.MeshStandardMaterial({ color: '#166534' }));
                foliage.position.y = 2.8;
                group.add(trunk, foliage);
                group.userData = { type: 'Exterieur', element: 'arbre', name: 'Arbre' };
                return group;
            },
            buisson: () => {
                const geo = new THREE.SphereGeometry(1.2, 12, 12);
                const mat = new THREE.MeshStandardMaterial({ color: '#16a34a' });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 1.1;
                mesh.userData = { type: 'Exterieur', element: 'buisson', name: 'Buisson' };
                return mesh;
            },
            haie: () => {
                const geo = new THREE.BoxGeometry(4, 1.2, 0.6);
                const mat = new THREE.MeshStandardMaterial({ color: '#15803d' });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.6;
                mesh.userData = { type: 'Exterieur', element: 'haie', name: 'Haie' };
                return mesh;
            },
            portail: () => {
                const group = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 0.2), new THREE.MeshStandardMaterial({ color: '#475569' }));
                frame.position.y = 1;
                const door = new THREE.Mesh(new THREE.BoxGeometry(3.6, 1.6, 0.1), new THREE.MeshStandardMaterial({ color: '#94a3b8' }));
                door.position.y = 1;
                group.add(frame, door);
                group.userData = { type: 'Exterieur', element: 'portail', name: 'Portail' };
                return group;
            },
            poubelle: () => {
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.2, 10), new THREE.MeshStandardMaterial({ color: '#0f172a' }));
                body.position.y = 0.6;
                const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.55, 0.55, 0.1, 10), new THREE.MeshStandardMaterial({ color: '#1e293b' }));
                lid.position.y = 1.2;
                const group = new THREE.Group(); group.add(body, lid);
                group.userData = { type: 'Exterieur', element: 'poubelle', name: 'Poubelle' };
                return group;
            },
            grillage: () => {
                const posts = new THREE.Group();
                for(let i = 0; i < 5; i++) {
                    const post = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.4, 0.1), new THREE.MeshStandardMaterial({ color: '#475569' }));
                    post.position.set(-2 + i, 0.7, 0);
                    posts.add(post);
                }
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 0.05), new THREE.MeshStandardMaterial({ color: '#cbd5e1', transparent: true, opacity: 0.5 }));
                mesh.position.y = 0.9;
                const group = new THREE.Group(); group.add(posts, mesh);
                group.userData = { type: 'Exterieur', element: 'grillage', name: 'Grillage' };
                return group;
            },
            parking: () => {
                const base = new THREE.Mesh(new THREE.BoxGeometry(6, 0.05, 4), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                base.receiveShadow = true;
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 3.6), new THREE.MeshStandardMaterial({ color: '#eab308' }));
                line.position.set(0, 0.04, 0);
                const group = new THREE.Group();
                group.add(base, line);
                group.userData = { type: 'Exterieur', element: 'parking', name: 'Parking' };
                return group;
            }
        };

        // --- STATE MANAGEMENT ---
        class StateManager {
            constructor(app) {
                this.app = app;
                this.history = [];
                this.redoStack = [];
                this.maxHistory = 30;
                this.isLocked = false;
            }
            snapshot() {
                if (this.isLocked) return;
                const state = this.app.serializeScene();
                if (this.history.length > 0 && JSON.stringify(this.history[this.history.length - 1]) === JSON.stringify(state)) return;
                this.history.push(state);
                if (this.history.length > this.maxHistory) this.history.shift();
                this.redoStack = []; 
                this.updateUI();
            }
            undo() {
                if (this.history.length === 0) return;
                const current = this.app.serializeScene();
                this.redoStack.push(current);
                const previous = this.history.pop();
                this.isLocked = true; this.app.loadScene(previous); this.isLocked = false;
                this.app.showToast('Annulé', 'info'); this.updateUI();
            }
            redo() {
                if (this.redoStack.length === 0) return;
                const next = this.redoStack.pop();
                this.history.push(this.app.serializeScene()); 
                this.isLocked = true; this.app.loadScene(next); this.isLocked = false;
                this.app.showToast('Rétabli', 'info'); this.updateUI();
            }
            updateUI() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                if(undoBtn) undoBtn.disabled = this.history.length === 0;
                if(redoBtn) redoBtn.disabled = this.redoStack.length === 0;
            }
        }

        // --- MAIN APPLICATION ---
        class HotelArchitect {
            constructor() {
                  this.scene = null; this.camera = null; this.renderer = null;
                  this.orbit = null; this.control = null; this.raycaster = new THREE.Raycaster(); this.pointer = new THREE.Vector2();
                  this.floors = { current: 0, max: 0 }; this.roomCounter = 1;
                  this.selectedObject = null; this.selectionLocked = false; this.isGlobalView = false; this.colorTarget = 'block'; this.opacityTarget = 'walls'; this.labelsVisible = true;
                  this.multiSelectEnabled = false; this.multiSelection = new Set();
                  this.cablesVisible = true; this.cableMaterials = [];
                  this.breakerCableGroup = null;
                  this.furnitureChoices = [
                      { value: 'crib', label: 'Lit bébé' },
                      { value: 'singleBed', label: 'Lit simple (1 personne)' },
                      { value: 'doubleBed', label: 'Lit double (2 personnes)' },
                      { value: 'bunkBed', label: 'Lit superposé (mixte)' },
                      { value: 'desk', label: 'Bureau' },
                      { value: 'chair', label: 'Chaise' },
                      { value: 'table', label: 'Table' },
                      { value: 'kitchenTable', label: 'Table de cuisine' },
                      { value: 'shower', label: 'Douche' },
                      { value: 'bathtub', label: 'Baignoire' },
                      { value: 'wardrobe', label: 'Armoire' },
                      { value: 'washer', label: 'Lave-linge' },
                      { value: 'dryer', label: 'Sèche-linge' },
                      { value: 'fridge', label: 'Réfrigérateur' },
                      { value: 'fireExtinguisher', label: 'Extincteur incendie' },
                      { value: 'smokeDetector', label: 'Détecteur de fumée' },
                      { value: 'hood', label: 'Hotte de cuisine' },
                      { value: 'cooktop', label: 'Plaque chauffante' },
                      { value: 'microwave', label: 'Micro-onde' },
                      { value: 'dumpster', label: 'Benne à ordures' },
                      { value: 'camera', label: 'Caméra de surveillance' },
                      { value: 'fireAlarm', label: 'Alarme incendie' },
                      { value: 'fireCabinet', label: 'Armoire alarme incendie' },
                      { value: 'mainBreaker', label: 'Grand tableau électrique' },
                      { value: 'waterHeater', label: 'Ballon d’eau chaude' },
                      { value: 'window', label: 'Fenêtre' },
                      { value: 'door', label: 'Porte' },
                      { value: 'toilet', label: 'WC' },
                      { value: 'sink', label: 'Évier' },
                      { value: 'balcony', label: 'Balcon' },
                      { value: 'frenchDoor', label: 'Porte-fenêtre' },
                      { value: 'innerWall', label: 'Mur intérieur' },
                      { value: 'wcDoor', label: 'Porte WC' },
                      { value: 'mirror', label: 'Miroir' },
                      { value: 'wallLamp', label: 'Lampe murale' },
                      { value: 'wallNeon', label: 'Néon mural' },
                      { value: 'heater', label: 'Chauffage' },
                      { value: 'breakerBox', label: 'Boîtier disjoncteurs' }
                  ];
                this.uiMode = 'chambre';
                this.stateManager = new StateManager(this); this.gridHelper = null;
                this.init();
            }

            activateBuilderTab(tab) {
                const tabs = document.querySelectorAll('[data-builder-tab]');
                const panels = document.querySelectorAll('[data-builder-panel]');
                tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.builderTab === tab));
                panels.forEach(panel => panel.classList.toggle('hidden', panel.dataset.builderPanel !== tab));
            }

            activateInspectorTab(tab) {
                const tabs = document.querySelectorAll('[data-inspector-tab]');
                const panels = document.querySelectorAll('[data-inspector-panel]');
                tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.inspectorTab === tab));
                panels.forEach(panel => panel.classList.toggle('hidden', panel.dataset.inspectorPanel !== tab));
            }

            setUIMode(mode) {
                this.uiMode = mode;
                document.querySelectorAll('[data-mode-btn]').forEach(btn => {
                    const active = btn.dataset.modeBtn === mode;
                    btn.classList.toggle('active', active);
                });
                const chip = document.getElementById('modeChip');
                if(chip) {
                    const labels = { chambre: 'Mode chambre', construction: 'Mode construction', exterieur: 'Mode extérieur' };
                    chip.textContent = labels[mode] || `Mode ${mode}`;
                }
                if(mode === 'construction') this.activateBuilderTab('construction');
                else if(mode === 'exterieur') this.activateBuilderTab('exterieur');
                else this.activateBuilderTab('chambre');
            }

              getFloorY(floorIndex) {
                  return floorIndex * (CONFIG.floorHeight + CONFIG.floorGap);
              }

              getTypeYOffset(type) {
                  if(!type) return 0;
                  const normalized = typeof type === 'string' ? type.toLowerCase() : '';
                  if(normalized === 'couloir' || normalized === 'corridor' || normalized === 'zone' || normalized === 'generic') {
                      return CONFIG.floorHeight / 2;
                  }
                  return 0;
              }

              makeRoomId() {
                  return 'room-' + Math.random().toString(36).slice(2, 7) + Date.now().toString(36);
              }

              ensureRoomId(room, force = false) {
                  if(!room || room.userData?.type !== 'Chambre') return;
                  if(force || !room.userData.roomId) room.userData.roomId = this.makeRoomId();
              }

              ensureRoomWallMetadata(room) {
                  if(!room || room.userData?.type !== 'Chambre') return;
                  if(!Array.isArray(room.userData.walls)) {
                      room.userData.walls = ['north','south','east','west'];
                  }
                  const shell = room.getObjectByName('RoomShell');
                  if(!shell) return;
                  shell.children.forEach(child => {
                      if(child.userData?.isWall && !child.userData.orientation) {
                          child.userData.orientation = this.detectWallOrientation(child);
                      }
                  });
              }

              detectWallOrientation(wall) {
                  if(!wall) return null;
                  const pos = wall.position;
                  const w = CONFIG.roomWidth, d = CONFIG.roomDepth;
                  const tol = 0.2;
                  if(Math.abs(pos.z + d/2 - 0.1) < tol) return 'north';
                  if(Math.abs(pos.z - (d/2 - 0.1)) < tol) return 'south';
                  if(Math.abs(pos.x + w/2 - 0.1) < tol) return 'west';
                  if(Math.abs(pos.x - (w/2 - 0.1)) < tol) return 'east';
                  return wall.userData?.orientation || null;
              }

              getRoomWalls(room) {
                  if(!room || room.userData?.type !== 'Chambre') return [];
                  this.ensureRoomWallMetadata(room);
                  const shell = room.getObjectByName('RoomShell');
                  if(!shell) return [];
                  const labels = { north: 'Nord', south: 'Sud', east: 'Est', west: 'Ouest' };
                  const walls = [];
                  shell.children.forEach(child => {
                      if(child.userData?.isWall) {
                          const orientation = child.userData.orientation || this.detectWallOrientation(child);
                          if(orientation) {
                              child.userData.orientation = orientation;
                              walls.push({ mesh: child, orientation, label: labels[orientation] || orientation });
                          }
                      }
                  });
                  return walls;
              }

              applyRoomWallState(room) {
                  if(!room || room.userData?.type !== 'Chambre') return;
                  this.ensureRoomWallMetadata(room);
                  const desired = new Set(Array.isArray(room.userData.walls) ? room.userData.walls : ['north','south','east','west']);
                  const shell = room.getObjectByName('RoomShell');
                  if(!shell) return;
                  shell.children
                      .filter(child => child.userData?.isWall)
                      .forEach(child => {
                          const orientation = child.userData.orientation || this.detectWallOrientation(child);
                          if(!orientation) return;
                          child.userData.orientation = orientation;
                          if(!desired.has(orientation)) shell.remove(child);
                      });
                  room.userData.walls = Array.from(desired);
              }

              refreshWallUI(room) {
                  const section = document.getElementById('wallSection');
                  const select = document.getElementById('wallSelector');
                  const btn = document.getElementById('removeWallBtn');
                  if(!section || !select || !btn) return;
                  if(!room || room.userData?.type !== 'Chambre') {
                      section.classList.add('hidden');
                      select.innerHTML = '';
                      btn.disabled = true;
                      return;
                  }
                  const walls = this.getRoomWalls(room);
                  select.innerHTML = '';
                  walls.forEach(w => {
                      const opt = document.createElement('option');
                      opt.value = w.orientation; opt.textContent = w.label;
                      select.appendChild(opt);
                  });
                  section.classList.toggle('hidden', walls.length === 0);
                  btn.disabled = walls.length === 0;
              }

              removeSelectedWall() {
                  if(!this.selectedObject || this.selectedObject.userData?.type !== 'Chambre') return;
                  const room = this.selectedObject;
                  const select = document.getElementById('wallSelector');
                  if(!select || !select.value) { this.showToast('Sélectionnez un mur', 'error'); return; }
                  const shell = room.getObjectByName('RoomShell');
                  if(!shell) return;
                  const walls = this.getRoomWalls(room);
                  const target = walls.find(w => w.orientation === select.value);
                  if(!target) { this.showToast('Mur introuvable', 'error'); return; }
                  shell.remove(target.mesh);
                  const currentList = Array.isArray(room.userData.walls) ? room.userData.walls : [];
                  room.userData.walls = currentList.filter(o => o !== target.orientation);
                  this.applyRoomWallState(room);
                  this.refreshWallUI(room);
                  this.stateManager.snapshot();
                  this.showToast(`Mur ${target.label} supprimé`, 'success');
              }

              listRooms() {
                  const rooms = [];
                  this.scene.traverse(o => { if(o.userData?.type === 'Chambre') rooms.push(o); });
                  return rooms;
              }

              getRoomById(id) {
                  if(!id) return null;
                  return this.listRooms().find(r => r.userData?.roomId === id) || null;
              }

              init() {
                  this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color('#e0f2fe');
                this.scene.fog = new THREE.FogExp2(0xe0f2fe, 0.008);
                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(30, 40, 40); this.camera.lookAt(0, 0, 0);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true; this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 1.5);
                sun.position.set(50, 80, 30); sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
                const d = 60; sun.shadow.camera.left = -d; sun.shadow.camera.right = d; sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
                sun.shadow.bias = -0.0005; this.scene.add(sun);

                this.gridHelper = new THREE.GridHelper(100, 200, 0x94a3b8, 0xcbd5e1);
                this.gridHelper.position.y = this.getFloorY(this.floors.current);
                this.scene.add(this.gridHelper);
                const planeGeo = new THREE.PlaneGeometry(200, 200);
                  const planeMat = new THREE.ShadowMaterial({ opacity: 0.05, color: 0x000000 });
                  const ground = new THREE.Mesh(planeGeo, planeMat);
                  ground.rotation.x = -Math.PI / 2; ground.name = "Ground"; ground.receiveShadow = true; this.scene.add(ground);

                  this.breakerCableGroup = new THREE.Group();
                  this.breakerCableGroup.name = 'BreakerCables';
                  this.breakerCableGroup.visible = this.cablesVisible;
                  this.scene.add(this.breakerCableGroup);

                  this.orbit = new OrbitControls(this.camera, this.renderer.domElement);
                  this.orbit.enableDamping = true; this.orbit.dampingFactor = 0.05; this.orbit.maxPolarAngle = Math.PI / 2 - 0.05;

                this.control = new TransformControls(this.camera, this.renderer.domElement);
                this.control.addEventListener('dragging-changed', (e) => { this.orbit.enabled = !e.value; });
                this.control.addEventListener('mouseUp', () => { this.stateManager.snapshot(); this.updateStats(); });
                this.control.addEventListener('change', () => { if (this.control.object) this.snapObject(this.control.object); });
                this.scene.add(this.control);

                window.addEventListener('resize', () => this.onResize());
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                this.renderer.domElement.addEventListener('pointerdown', (e) => this.onPointerDown(e));
                
                  this.bindUI(); this.initColorPalette();
                  this.renderer.setAnimationLoop(() => this.animate());
                  lucide.createIcons();
                  this.updateCableToggleButton();
                  document.getElementById('loader').style.opacity = 0; setTimeout(() => document.getElementById('loader').remove(), 500);

                this.createBlock('room');
                this.updateUI();
                this.stateManager.snapshot(); this.updateStats();
            }

            bindUI() {
                document.querySelectorAll('[data-builder-tab]').forEach(btn => btn.onclick = () => this.activateBuilderTab(btn.dataset.builderTab));
                document.querySelectorAll('[data-inspector-tab]').forEach(btn => btn.onclick = () => this.activateInspectorTab(btn.dataset.inspectorTab));
                document.querySelectorAll('[data-mode-btn]').forEach(btn => btn.onclick = () => this.setUIMode(btn.dataset.modeBtn));
                document.getElementById('toolTranslate').onclick = () => this.setMode('translate');
                document.getElementById('toolRotate').onclick = () => this.setMode('rotate');
                document.getElementById('toolScale').onclick = () => this.setMode('scale');
                document.getElementById('floorUp').onclick = () => this.changeFloor(1);
                document.getElementById('floorDown').onclick = () => this.changeFloor(-1);
                document.getElementById('addFloorBtn').onclick = () => this.addFloor();
                document.getElementById('cloneFloorBtn').onclick = () => this.cloneCurrentFloor();
                document.getElementById('viewFloor').onclick = () => this.setGlobalView(false);
                document.getElementById('viewGlobal').onclick = () => this.setGlobalView(true);
                document.getElementById('deleteBtn').onclick = () => this.deleteSelection();
                document.getElementById('duplicateBtn').onclick = () => this.duplicateSelection();
                document.getElementById('propNameBtn').onclick = () => this.updateObjectName();
                document.getElementById('propName').addEventListener('keypress', (e) => { if(e.key === 'Enter') this.updateObjectName() });
                document.getElementById('targetBlock').onclick = (e) => this.setColorTarget('block', e.target);
                document.getElementById('targetLabel').onclick = (e) => this.setColorTarget('label', e.target);
                document.getElementById('selectionLockBtn').onclick = () => this.toggleSelectionLock();
                document.getElementById('multiSelectToggle').onchange = (e) => this.setMultiSelectionEnabled(e.target.checked);
                document.getElementById('saveBtn').onclick = () => this.saveToFile();
                document.getElementById('loadBtn').onclick = () => document.getElementById('fileInput').click();
                document.getElementById('fileInput').onchange = (e) => this.loadFile(e);
                document.getElementById('resetBtn').onclick = () => this.resetScene();
                document.getElementById('undoBtn').onclick = () => this.stateManager.undo();
                document.getElementById('redoBtn').onclick = () => this.stateManager.redo();
                document.getElementById('removeWallBtn').onclick = () => this.removeSelectedWall();
                document.getElementById('rotateClockwise').onclick = () => this.applyPresetRotation('cw');
                document.getElementById('rotateCounter').onclick = () => this.applyPresetRotation('ccw');
                document.getElementById('opacityTargetWalls').onclick = () => this.setOpacityTarget('walls');
                document.getElementById('opacityTargetFurniture').onclick = () => this.setOpacityTarget('furniture');
                document.getElementById('opacityInput').addEventListener('input', (e) => this.updateSelectionOpacity(parseFloat(e.target.value), false));
                document.getElementById('opacityInput').addEventListener('change', (e) => this.updateSelectionOpacity(parseFloat(e.target.value), true));
                document.getElementById('labelSizeInput').oninput = (e) => this.updateLabelScale(parseFloat(e.target.value));
                document.getElementById('labelTextColorInput').oninput = (e) => this.updateLabelTextColor(e.target.value);
                ['X','Y','Z'].forEach(axis => {
                    document.getElementById('labelPos'+axis).onchange = (e) => this.updateLabelOffset(axis.toLowerCase(), parseFloat(e.target.value));
                });
                [
                    { id: 'structureLengthInput', axis: 'x' },
                    { id: 'structureWidthInput', axis: 'z' },
                    { id: 'structureHeightInput', axis: 'y' }
                ].forEach(cfg => {
                    const el = document.getElementById(cfg.id);
                    if(el) el.onchange = (e) => this.updateStructureDimension(cfg.axis, e.target.value);
                });
                  document.getElementById('toggleDoorLabelBtn').onclick = () => this.toggleDoorLabel();
                  document.getElementById('toggleLabelBtn').onclick = () => this.toggleSelectedLabel();
                  document.getElementById('toggleAllLabelsBtn').onclick = () => this.toggleAllLabels();
                  this.populateFurnitureSelector();
                  document.getElementById('addFurnitureBtn').onclick = () => this.addFurnitureFromMenu();
                  document.getElementById('removeFurnitureBtn').onclick = () => this.removeFurnitureFromMenu();
                  document.getElementById('toggleCablesBtn').onclick = () => this.toggleBreakerCables();
                  document.getElementById('breakerSelectAll').onclick = () => this.selectAllBreakerRooms();
                  document.getElementById('breakerRoomsList').addEventListener('change', (e) => {
                      if(e.target?.dataset?.roomId) this.setBreakerFeed(this.selectedObject, e.target.dataset.roomId, e.target.checked);
                  });
                ['X','Y','Z'].forEach(axis => {
                    document.getElementById('furnScale'+axis).onchange = (e) => this.updateFurnitureScale(axis.toLowerCase(), parseFloat(e.target.value));
                });
                  document.getElementById('furnRotationY').onchange = (e) => this.updateFurnitureRotation(parseFloat(e.target.value));
                this.activateBuilderTab('chambre');
                this.activateInspectorTab('essentiel');
                this.setUIMode(this.uiMode);
                this.setColorTarget('block');
                this.updateSelectionChips();
                this.updateSelectionLockUI();
            }
            
            initColorPalette() {
                const container = document.getElementById('colorGrid');
                CONFIG.colors.forEach(color => {
                    const btn = document.createElement('div');
                    btn.className = 'color-swatch w-6 h-6 rounded-full shadow-sm';
                    btn.style.backgroundColor = color;
                    btn.onclick = () => this.applyColor(color);
                    container.appendChild(btn);
                });
            }

            populateFurnitureSelector() {
                const select = document.getElementById('furnitureSelector');
                select.innerHTML = '';
                this.furnitureChoices.forEach(opt => {
                    const o = document.createElement('option');
                    o.value = opt.value; o.textContent = opt.label; select.appendChild(o);
                });
            }

            getSizeFactor(size) {
                if(size === 'petite') return 0.9;
                if(size === 'grande') return 1.35;
                return 1.1;
            }

            getPresetFurniture(kind, size = 'moyenne') {
                const commonShelves = [{ type: 'wardrobe', pos: [1.6, 1.2, -2.2] }];
                const presets = {
                    cuisine: [
                        { type: 'fridge', pos: [-1.7, 0, -2.2] },
                        { type: 'kitchenTable', pos: [0, 0, 0.6] },
                        { type: 'cooktop', pos: [-0.4, 0.85, 1.8] },
                        { type: 'hood', pos: [-0.4, 2, 1.8] },
                        { type: 'microwave', pos: [1.6, 1.2, 1.4] },
                        { type: 'sink', pos: [1.6, 0, -1.6] },
                        { type: 'fireExtinguisher', pos: [-1.9, 0, 2.2] },
                        { type: 'smokeDetector', pos: [0, CONFIG.floorHeight - 0.2, 0] }
                    ],
                    bain: [
                        { type: 'shower', pos: [-1.6, 0, -2.4] },
                        { type: 'bathtub', pos: [1.6, 0, -1.8] },
                        { type: 'toilet', pos: [1.6, 0, 1.6] },
                        { type: 'sink', pos: [0, 0, 1.8] },
                        { type: 'mirror', pos: [0, 1.3, 1.85] },
                        { type: 'wallLamp', pos: [-0.4, 1.8, 1.8] }
                    ],
                    buanderie: [
                        { type: 'washer', pos: [-1.2, 0, -1.6] },
                        { type: 'dryer', pos: [-0.2, 0, -1.6] },
                        { type: 'waterHeater', pos: [1.6, 0, 1.6] },
                        { type: 'table', pos: [0, 0, 0.4] }
                    ],
                    atelier: [
                        { type: 'table', pos: [0, 0, 0] },
                        { type: 'chair', pos: [0.6, 0, 0.6] },
                        { type: 'fireExtinguisher', pos: [-1.8, 0, 2.2] },
                        { type: 'camera', pos: [0, 2.4, -2.4] }
                    ],
                    bureau: [
                        { type: 'desk', pos: [1.4, 0, -1.8] },
                        { type: 'chair', pos: [1.0, 0, -1.0] },
                        { type: 'table', pos: [0, 0, 1.2] },
                        { type: 'tv', pos: [-1.6, 1.6, 0] }
                    ],
                    reserve: [
                        ...commonShelves,
                        { type: 'innerWall', pos: [0, 0, 0], rot: [0, Math.PI / 2, 0] },
                        { type: 'dumpster', pos: [0, 0, 1.8] }
                    ],
                    lingerie: [
                        { type: 'wardrobe', pos: [1.5, 1.2, -2.2] },
                        { type: 'chair', pos: [0, 0, 0.2] },
                        { type: 'fireAlarm', pos: [-1.8, 2.4, 0] }
                    ],
                    reunion: [
                        { type: 'table', pos: [0, 0, 0] },
                        { type: 'chair', pos: [0, 0, 1.2] },
                        { type: 'chair', pos: [1.2, 0, -0.8] },
                        { type: 'chair', pos: [-1.2, 0, -0.8] },
                        { type: 'camera', pos: [0, 2.4, -2.2] }
                    ]
                };
                return presets[kind] ? presets[kind].map(item => ({ ...item })) : [];
            }

            createPresetSpace(kind, size = 'moyenne') {
                const furnitureList = this.getPresetFurniture(kind, size);
                const room = this.createBlock('room', furnitureList);
                if(room) {
                    const factor = this.getSizeFactor(size);
                    room.scale.set(factor, 1, factor);
                    const labels = {
                        cuisine: 'Cuisine', bain: 'Salle de bain', buanderie: 'Buanderie',
                        atelier: 'Atelier', bureau: 'Bureau', reserve: 'Réserve',
                        lingerie: 'Lingerie', reunion: 'Salle de réunion'
                    };
                    const readable = labels[kind] || 'Espace';
                    room.userData.structureKind = readable;
                    room.userData.sizeVariant = size;
                    room.userData.name = `${readable} ${size}`;
                    room.userData.labelText = readable.slice(0, 1).toUpperCase();
                    this.addLabel(room, room.userData.labelText);
                }
                return room;
            }

            createBlock(type, furnitureList = null, floorOverride = null) {
                let mesh;
                const targetFloor = floorOverride ?? this.floors.current;
                const yPos = this.getFloorY(targetFloor);
                const randX = Math.round((Math.random() * 4 - 2)) * 1;
                const randZ = Math.round((Math.random() * 4 - 2)) * 1;

                if (type === 'room') {
                    mesh = new THREE.Group();
                    const w = CONFIG.roomWidth, h = CONFIG.floorHeight, d = CONFIG.roomDepth;

                    // --- STRUCTURE ---
                    const shellGroup = new THREE.Group();
                    shellGroup.name = "RoomShell";
                    const matWall = new THREE.MeshStandardMaterial({ color: '#6366f1', roughness: 0.4 });
                    const matFloor = new THREE.MeshStandardMaterial({ color: '#e2e8f0', roughness: 0.8 });

                    // Sol
                    const floor = new THREE.Mesh(new THREE.BoxGeometry(w, 0.2, d), matFloor);
                    floor.position.y = 0.1; floor.receiveShadow = true; floor.userData = { isFloor: true }; shellGroup.add(floor);
                    
                    // Murs Pleins (4 Côtés)
                    const back = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.2), matWall.clone()); back.position.set(0, h/2, -d/2+0.1); back.userData = { isWall: true, orientation: 'north' }; back.name = 'Wall-North'; shellGroup.add(back);
                    const front = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.2), matWall.clone()); front.position.set(0, h/2, d/2-0.1); front.userData = { isWall: true, orientation: 'south' }; front.name = 'Wall-South'; shellGroup.add(front);
                    const left = new THREE.Mesh(new THREE.BoxGeometry(0.2, h, d), matWall.clone()); left.position.set(-w/2+0.1, h/2, 0); left.userData = { isWall: true, orientation: 'west' }; left.name = 'Wall-West'; shellGroup.add(left);
                    const right = new THREE.Mesh(new THREE.BoxGeometry(0.2, h, d), matWall.clone()); right.position.set(w/2-0.1, h/2, 0); right.userData = { isWall: true, orientation: 'east' }; right.name = 'Wall-East'; shellGroup.add(right);
                    
                    mesh.add(shellGroup);

                    // --- MOBILIER ---
                    const furnitureGroup = new THREE.Group();
                    furnitureGroup.name = "Furniture";
                    
                      if (furnitureList) {
                          furnitureList.forEach(item => {
                              const fMesh = FurnitureFactory[item.type]();
                              fMesh.position.fromArray(item.pos);
                              fMesh.rotation.set(item.rot?.[0] || 0, item.rot?.[1] || 0, item.rot?.[2] || 0);
                              if(item.scale) fMesh.scale.fromArray(item.scale);
                              if(item.userData) fMesh.userData = {...fMesh.userData, ...item.userData};
                              furnitureGroup.add(fMesh);
                          });
                      } else {
                        // Layout Par défaut
                        const bed = FurnitureFactory.bed(); bed.position.set(0, 0, -1.5); furnitureGroup.add(bed);
                        const shower = FurnitureFactory.shower(); shower.position.set(-1.3, 0, -2.3); furnitureGroup.add(shower);
                        const desk = FurnitureFactory.desk(); desk.position.set(1.6, 0, 0.5); furnitureGroup.add(desk);
                        const wardrobe = FurnitureFactory.wardrobe(); wardrobe.position.set(1.5, 1.2, -2.5); furnitureGroup.add(wardrobe); // ward has defaultY
                        const chair = FurnitureFactory.chair(); chair.position.set(1.0, 0, 0.5); furnitureGroup.add(chair);
                        const tv = FurnitureFactory.tv(); tv.position.set(-1.8, 1.5, 0); furnitureGroup.add(tv);
                        
                        // Porte & Fenêtre par défaut
                        const door = FurnitureFactory.door(); 
                        door.position.set(-0.5, 0, d/2 - 0.1); 
                        furnitureGroup.add(door);

                        const win = FurnitureFactory.window();
                        win.position.set(1.0, win.userData.defaultY, -d/2 + 0.1); // FIX Y
                        furnitureGroup.add(win);
                    }
                    mesh.add(furnitureGroup);

                    const hitBox = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshBasicMaterial({visible: false}));
                    hitBox.position.y = h/2; hitBox.name = "StructureHitbox"; 
                    mesh.add(hitBox);

                    mesh.userData = {
                        type: 'Chambre',
                        name: `Chambre ${this.roomCounter}`,
                        labelText: this.roomCounter.toString(),
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                          labelScale: CONFIG.defaultLabelScale,
                          labelOffset: {...CONFIG.defaultLabelOffset},
                          labelVisible: true,
                          doorLabelVisible: true,
                          roomId: this.makeRoomId(),
                          wallColor: '#6366f1',
                          walls: ['north','south','east','west'],
                          opacity: 1,
                          wallOpacity: 1,
                          furnitureOpacity: 1
                      };
                    this.roomCounter++;
                }
                else if (type === 'corridor') {
                    const geo = new THREE.BoxGeometry(10, CONFIG.floorHeight, 2);
                    const mat = new THREE.MeshStandardMaterial({ color: '#14b8a6' });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.userData = {
                        type: 'Couloir',
                        name: 'Couloir',
                        labelText: '',
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                        labelScale: CONFIG.defaultLabelScale,
                        labelOffset: {...CONFIG.defaultLabelOffset},
                        labelVisible: true,
                        doorLabelVisible: true,
                        opacity: 1
                    };
                } else if (type === 'generic') {
                    const geo = new THREE.BoxGeometry(4, CONFIG.floorHeight, 4);
                    const mat = new THREE.MeshStandardMaterial({ color: '#64748b' });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.userData = {
                        type: 'Zone',
                        name: 'Zone',
                        labelText: 'Zone',
                        labelColor: CONFIG.defaultLabelColor,
                        textColor: CONFIG.defaultTextColor,
                        labelScale: CONFIG.defaultLabelScale,
                        labelOffset: {...CONFIG.defaultLabelOffset},
                        labelVisible: true,
                        doorLabelVisible: true,
                        opacity: 1
                    };
                } else if (type === 'stairs') {
                    mesh = new THREE.Group();
                    const steps = 8; const stepH = CONFIG.floorHeight/steps; const stepD = 4/steps;
                    for(let i=0; i<steps; i++) {
                        const s = new THREE.Mesh(new THREE.BoxGeometry(2, stepH, stepD), new THREE.MeshStandardMaterial({color: '#f97316'}));
                        s.position.set(0, (i*stepH)+(stepH/2), (i*stepD)-2); s.castShadow=true; mesh.add(s);
                    }
                    const hit = new THREE.Mesh(new THREE.BoxGeometry(2, CONFIG.floorHeight, 4), new THREE.MeshBasicMaterial({visible:false}));
                    hit.position.y = CONFIG.floorHeight/2; mesh.add(hit);
                    mesh.userData = { type: 'Escalier', name: 'Escalier', opacity: 1 };
                }

                if (mesh) {
                    this.captureBaseSize(mesh);
                    const yOffset = this.getTypeYOffset(mesh.userData?.type || type);
                    mesh.position.set(randX, yPos + yOffset, randZ);
                    mesh.userData.floor = targetFloor;
                    mesh.userData.labelColor = CONFIG.defaultLabelColor;
                    mesh.userData.textColor = CONFIG.defaultTextColor;

                    mesh.traverse(c => { if(c.isMesh && c.visible) { c.castShadow=true; c.receiveShadow=true; } });
                    this.applyStoredOpacityToObject(mesh);
                    if (mesh.userData.labelText) this.addLabel(mesh, mesh.userData.labelText);
                    else this.refreshDoorLabels(mesh);
                    if (mesh.userData.type === 'Chambre') {
                        this.setRoomWallColor(mesh, mesh.userData.wallColor || '#6366f1');
                        this.applyRoomWallState(mesh);
                    }

                    this.scene.add(mesh);
                    this.selectObject(mesh);
                    this.stateManager.snapshot(); this.updateStats(); this.showToast(`${mesh.userData.name} créé`, 'success');
                }
                return mesh;
            }

            createApartment(size = 'moyenne') {
                const factor = this.getSizeFactor(size);
                const baseX = Math.round((Math.random() * 6 - 3));
                const baseZ = Math.round((Math.random() * 4 - 2));
                const spacing = CONFIG.roomWidth * factor + 1;
                const presets = ['cuisine', 'reunion', 'bain'];
                presets.forEach((preset, index) => {
                    const room = this.createBlock('room', this.getPresetFurniture(preset, size));
                    if(room) {
                        room.scale.set(factor, 1, factor);
                        room.position.set(baseX + (index - 1) * spacing, this.getFloorY(this.floors.current), baseZ);
                        room.userData.structureKind = 'Appartement';
                        room.userData.sizeVariant = size;
                        room.userData.name = `Appartement ${size} - Pièce ${index + 1}`;
                        room.userData.labelText = `A${index + 1}`;
                        this.addLabel(room, room.userData.labelText);
                    }
                });
            }

            placeExteriorElement(element, floorOverride = 0) {
                if(!element) return null;
                const randX = Math.round((Math.random() * 8 - 4));
                const randZ = Math.round((Math.random() * 8 - 4));
                const targetFloor = floorOverride ?? 0;
                element.position.set(randX, this.getFloorY(targetFloor), randZ);
                element.userData.floor = targetFloor;
                element.userData.labelColor = CONFIG.defaultLabelColor;
                element.userData.textColor = CONFIG.defaultTextColor;
                element.userData.labelScale = CONFIG.defaultLabelScale;
                element.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                element.userData.labelVisible = false;
                element.userData.isExterior = true;
                element.userData.opacity = element.userData.opacity ?? 1;
                this.captureBaseSize(element);
                this.applyStoredOpacityToObject(element);
                this.scene.add(element);
                if(targetFloor > this.floors.max) { this.floors.max = targetFloor; this.updateUI(); }
                this.updateFloorVisibility();
                this.selectObject(element);
                this.stateManager.snapshot(); this.updateStats();
                this.showToast(`${element.userData.name} ajoutée`, 'success');
                return element;
            }

            createExterior(type, floorOverride = 0) {
                const factory = ExteriorFactory[type];
                if(!factory) { this.showToast('Élément extérieur inconnu', 'error'); return null; }
                const element = factory();
                return this.placeExteriorElement(element, floorOverride);
            }

            createExteriorPreset(kind, size = 'moyenne') {
                const factor = this.getSizeFactor(size);
                let element = null;
                if(kind === 'terrasse') {
                    const platform = new THREE.Mesh(new THREE.BoxGeometry(5 * factor, 0.2, 4 * factor), new THREE.MeshStandardMaterial({ color: '#fbbf24' }));
                    platform.position.y = 0.1;
                    const planters = new THREE.Mesh(new THREE.BoxGeometry(5 * factor, 0.4, 0.4), new THREE.MeshStandardMaterial({ color: '#16a34a' }));
                    planters.position.set(0, 0.2, 2 * factor);
                    const lights = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), new THREE.MeshStandardMaterial({ color: '#fde68a', emissive: '#f59e0b', emissiveIntensity: 0.8 }));
                    const group = new THREE.Group();
                    group.add(platform, planters);
                    for(let i = -1; i <= 1; i++) {
                        const copy = lights.clone();
                        copy.position.set(i * 1.5 * factor, 1.8, 0);
                        group.add(copy);
                    }
                    group.userData = { type: 'Exterieur', element: `terrasse-${size}`, name: `Terrasse ${size}`, structureKind: 'Terrasse', sizeVariant: size };
                    element = group;
                } else if(kind === 'parking') {
                    const base = new THREE.Mesh(new THREE.BoxGeometry(6 * factor, 0.05, 4 * factor), new THREE.MeshStandardMaterial({ color: '#cbd5e1' }));
                    base.receiveShadow = true;
                    const lineCount = factor > 1.2 ? 2 : 1;
                    const group = new THREE.Group();
                    group.add(base);
                    for(let i = 0; i < lineCount; i++) {
                        const line = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.06, 3.6 * factor), new THREE.MeshStandardMaterial({ color: '#eab308' }));
                        line.position.set((i - (lineCount - 1) / 2) * 2 * factor, 0.04, 0);
                        group.add(line);
                    }
                    group.userData = { type: 'Exterieur', element: `parking-${size}`, name: `Place de parking ${size}`, structureKind: 'Parking', sizeVariant: size };
                    element = group;
                }
                return this.placeExteriorElement(element, 0);
            }

            addLabel(parent, text) {
                this.ensureLabelDefaults(parent);
                const old = parent.getObjectByName('Label');
                if(old) parent.remove(old);
                if(!text) return;
                const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = parent.userData.labelColor || CONFIG.defaultLabelColor;
                ctx.beginPath(); ctx.roundRect(20, 20, 472, 216, 40); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 10; ctx.stroke();
                ctx.fillStyle = parent.userData.textColor || CONFIG.defaultTextColor;
                ctx.font = 'bold 120px Inter, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 256, 128);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false }));
                sprite.name = 'Label';
                const scale = parent.userData.labelScale || CONFIG.defaultLabelScale;
                sprite.scale.set(2 * scale, 1 * scale, 1);
                const offset = parent.userData.labelOffset || CONFIG.defaultLabelOffset;
                sprite.position.set(offset.x, offset.y, offset.z);
                sprite.visible = this.labelsVisible && parent.userData.labelVisible !== false;
                sprite.userData = { isLabel: true };
                parent.add(sprite);

                this.refreshDoorLabels(parent);
            }

            ensureLabelDefaults(obj) {
                if(!obj.userData.labelColor) obj.userData.labelColor = CONFIG.defaultLabelColor;
                if(!obj.userData.textColor) obj.userData.textColor = CONFIG.defaultTextColor;
                if(!obj.userData.labelScale) obj.userData.labelScale = CONFIG.defaultLabelScale;
                if(!obj.userData.labelOffset) obj.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                if(obj.userData.labelVisible === undefined) obj.userData.labelVisible = true;
                if(obj.userData.doorLabelVisible === undefined) obj.userData.doorLabelVisible = true;
            }

            supportsDoorBadge(obj) {
                if(!obj || obj.userData?.isFurniture) return false;
                const t = obj.userData.type;
                return ['Chambre', 'Zone', 'Generic', 'Couloir'].includes(t);
            }

            getDoorLabelText(obj) {
                if(!obj || obj.userData?.isFurniture) return '';
                if(obj.userData.type === 'Chambre') return obj.userData.labelText || obj.userData.name || '';
                if(obj.userData.type === 'Zone' || obj.userData.type === 'Generic' || obj.userData.type === 'Couloir') {
                    return obj.userData.name || obj.userData.labelText || '';
                }
                return '';
            }

            clearDoorBadges(obj) {
                if(!obj) return;
                const toRemove = [];
                obj.traverse(child => { if(child.name === 'DoorBadge') toRemove.push(child); });
                toRemove.forEach(c => c.parent?.remove(c));
            }

            createDoorBadge(text) {
                const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#111827';
                ctx.beginPath(); ctx.roundRect(16, 16, 224, 96, 20); ctx.fill();
                ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 6; ctx.stroke();
                ctx.fillStyle = '#f8fafc';
                ctx.font = text.length > 7 ? 'bold 56px Inter, Arial' : 'bold 72px Inter, Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, 128, 64);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const geometry = new THREE.PlaneGeometry(0.9, 0.45);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'DoorBadge';
                mesh.renderOrder = 5;
                return mesh;
            }

            attachDoorBadgeToDoor(doorMesh, text) {
                if(!doorMesh || !text) return false;
                const badge = this.createDoorBadge(text);
                badge.position.set(0, CONFIG.floorHeight * 0.45, 0.22);
                doorMesh.add(badge);
                return true;
            }

            attachDoorBadgeToFront(obj, text) {
                if(!obj || !text) return false;
                const badge = this.createDoorBadge(text);
                const depth = (obj.geometry?.parameters?.depth || CONFIG.roomDepth) * (obj.scale?.z || 1);
                badge.position.set(0, CONFIG.floorHeight * 0.45, (depth / 2) + 0.05);
                obj.add(badge);
                return true;
            }

            refreshDoorLabels(obj, allowFallback = true) {
                if(!this.supportsDoorBadge(obj)) return;
                this.ensureLabelDefaults(obj);
                this.clearDoorBadges(obj);
                const text = this.getDoorLabelText(obj);
                if(!text || obj.userData.doorLabelVisible === false) return;

                let attached = false;
                obj.traverse(child => {
                    if(child.userData?.type === 'door') {
                        if(this.attachDoorBadgeToDoor(child, text)) attached = true;
                    }
                });
                if(!attached && allowFallback) this.attachDoorBadgeToFront(obj, text);
            }

            captureBaseSize(obj) {
                if(!obj || obj.userData?.isFurniture) return;
                const target = obj.getObjectByName('StructureHitbox') || obj;
                const bbox = new THREE.Box3().setFromObject(target);
                const size = bbox.getSize(new THREE.Vector3());
                obj.userData.baseSize = {
                    x: size.x / (obj.scale?.x || 1),
                    y: size.y / (obj.scale?.y || 1),
                    z: size.z / (obj.scale?.z || 1)
                };
            }

            getStructureBaseSize(obj) {
                if(!obj || obj.userData?.isFurniture) return null;
                if(!obj.userData.baseSize) this.captureBaseSize(obj);
                return obj.userData.baseSize || null;
            }

            refreshStructureDimensionsUI(obj) {
                const section = document.getElementById('structureDimensionsSection');
                if(!section) return;
                if(!obj || obj.userData?.isFurniture) { section.classList.add('hidden'); return; }
                const base = this.getStructureBaseSize(obj);
                if(!base) { section.classList.add('hidden'); return; }
                const length = base.x * obj.scale.x;
                const height = base.y * obj.scale.y;
                const width = base.z * obj.scale.z;
                document.getElementById('structureLengthInput').value = length.toFixed(2);
                document.getElementById('structureWidthInput').value = width.toFixed(2);
                document.getElementById('structureHeightInput').value = height.toFixed(2);
                section.classList.remove('hidden');
            }

            updateStructureDimension(axis, value) {
                if(!this.selectedObject || this.selectedObject.userData?.isFurniture) return;
                const val = parseFloat(value);
                if(isNaN(val) || val <= 0) return;
                const base = this.getStructureBaseSize(this.selectedObject);
                if(!base) return;
                const baseSize = axis === 'x' ? base.x : axis === 'y' ? base.y : base.z;
                if(baseSize <= 0) return;
                this.selectedObject.scale[axis] = val / baseSize;
                this.snapObject(this.selectedObject);
                this.refreshStructureDimensionsUI(this.selectedObject);
                this.stateManager.snapshot();
                this.updateStats();
            }

            refreshLabelUI(obj) {
                if(!obj || obj.userData.isFurniture) return;
                this.ensureLabelDefaults(obj);
                document.getElementById('labelSizeInput').value = obj.userData.labelScale;
                document.getElementById('labelTextColorInput').value = obj.userData.textColor;
                document.getElementById('labelPosX').value = obj.userData.labelOffset.x;
                document.getElementById('labelPosY').value = obj.userData.labelOffset.y;
                document.getElementById('labelPosZ').value = obj.userData.labelOffset.z;
                document.getElementById('toggleLabelBtn').innerText = obj.userData.labelVisible === false ? 'Afficher' : 'Masquer';
                document.getElementById('toggleAllLabelsBtn').innerText = this.labelsVisible ? 'Masquer tout' : 'Afficher tout';
                const doorBtn = document.getElementById('toggleDoorLabelBtn');
                if(doorBtn) {
                    const supported = this.supportsDoorBadge(obj);
                    doorBtn.disabled = !supported;
                    doorBtn.classList.toggle('opacity-50', !supported);
                    doorBtn.classList.toggle('cursor-not-allowed', !supported);
                    doorBtn.innerText = obj.userData.doorLabelVisible === false ? 'Afficher porte' : 'Masquer porte';
                }
            }

              refreshFurnitureUI(obj) {
                  if(!obj || !obj.userData.isFurniture) return;
                  document.getElementById('furnScaleX').value = obj.scale.x.toFixed(2);
                  document.getElementById('furnScaleY').value = obj.scale.y.toFixed(2);
                  document.getElementById('furnScaleZ').value = obj.scale.z.toFixed(2);
                  const deg = THREE.MathUtils.radToDeg(obj.rotation.y);
                  document.getElementById('furnRotationY').value = Math.round(deg * 100) / 100;
              }

              refreshBreakerUI(obj) {
                  const section = document.getElementById('breakerSection');
                  const list = document.getElementById('breakerRoomsList');
                  if(!section || !list) return;
                  if(!obj || !obj.userData?.isBreaker) {
                      section.classList.add('hidden');
                      list.innerHTML = '';
                      return;
                  }

                  let roomParent = obj;
                  while(roomParent && !roomParent.userData?.type && roomParent.parent) roomParent = roomParent.parent;
                  this.ensureRoomId(roomParent);
                  const rooms = this.listRooms();
                  const feeds = obj.userData.feeds || [];
                  list.innerHTML = '';
                  rooms.sort((a,b) => (a.userData.name||'').localeCompare(b.userData.name||''));
                  rooms.forEach(room => {
                      this.ensureRoomId(room);
                      const id = room.userData.roomId;
                      const wrapper = document.createElement('label');
                      wrapper.className = 'flex items-center gap-2 bg-gray-50 border border-gray-200 rounded px-2 py-1';
                      const input = document.createElement('input');
                      input.type = 'checkbox';
                      input.dataset.roomId = id;
                      input.checked = feeds.includes(id);
                      input.className = 'accent-emerald-500';
                      const text = document.createElement('span');
                      text.className = 'flex-1 text-[11px] text-gray-700';
                      text.textContent = `${room.userData.name || 'Chambre'} (${this.formatFloorLabel(room.userData.floor || 0)})`;
                      wrapper.appendChild(input);
                      wrapper.appendChild(text);
                      list.appendChild(wrapper);
                  });
                  if(rooms.length === 0) list.innerHTML = '<div class="text-[10px] text-gray-400">Aucune chambre disponible</div>';
                  section.classList.remove('hidden');
              }

              updateCableToggleButton() {
                  const btn = document.getElementById('toggleCablesBtn');
                  if(!btn) return;
                  btn.innerHTML = `<i data-lucide="${this.cablesVisible ? 'eye-off' : 'eye'}" size="14"></i>${this.cablesVisible ? 'Masquer le câblage' : 'Afficher le câblage'}`;
                  lucide.createIcons({ root: btn });
              }

              toggleBreakerCables() {
                  this.cablesVisible = !this.cablesVisible;
                  if(this.breakerCableGroup) this.breakerCableGroup.visible = this.cablesVisible;
                  this.updateCableToggleButton();
                  this.stateManager.snapshot();
              }

              setBreakerFeed(breaker, roomId, enabled) {
                  if(!breaker?.userData?.isBreaker) return;
                  if(!breaker.userData.feeds) breaker.userData.feeds = [];
                  const exists = breaker.userData.feeds.includes(roomId);
                  if(enabled && !exists) breaker.userData.feeds.push(roomId);
                  if(!enabled && exists) breaker.userData.feeds = breaker.userData.feeds.filter(id => id !== roomId);
                  this.updateBreakerCables();
                  this.stateManager.snapshot();
              }

              selectAllBreakerRooms() {
                  const breaker = this.selectedObject;
                  if(!breaker?.userData?.isBreaker) return;
                  const rooms = this.listRooms();
                  rooms.forEach(r => this.ensureRoomId(r));
                  breaker.userData.feeds = rooms.map(r => r.userData.roomId);
                  this.updateBreakerCables();
                  this.refreshBreakerUI(breaker);
                  this.stateManager.snapshot();
              }

              updateBreakerCables() {
                  if(!this.breakerCableGroup) return;
                  this.breakerCableGroup.children.forEach(child => { child.geometry?.dispose?.(); child.material?.dispose?.(); });
                  this.breakerCableGroup.clear();
                  this.cableMaterials = [];
                  const rooms = this.listRooms();
                  rooms.forEach(r => this.ensureRoomId(r));
                  const roomIds = rooms.map(r => r.userData.roomId);

                  this.scene.traverse(obj => {
                      if(!obj.userData?.isBreaker) return;
                      if(!Array.isArray(obj.userData.feeds)) obj.userData.feeds = [];
                      obj.userData.feeds = obj.userData.feeds.filter(id => roomIds.includes(id));
                      obj.userData.feeds.forEach(id => {
                          const room = rooms.find(r => r.userData.roomId === id);
                          if(!room) return;
                          const start = obj.getWorldPosition(new THREE.Vector3());
                          start.y += 1.2;
                          const end = room.getWorldPosition(new THREE.Vector3());
                          end.y = this.getFloorY(room.userData.floor || 0) + CONFIG.floorHeight * 0.6;
                          const mid = start.clone().lerp(end, 0.5);
                          mid.y += 1.5;
                          const geometry = new THREE.BufferGeometry().setFromPoints([start, mid, end]);
                          const material = new THREE.LineDashedMaterial({ color: 0xf97316, dashSize: 0.8, gapSize: 0.35, transparent: true, opacity: 0.9 });
                          const line = new THREE.Line(geometry, material);
                          line.computeLineDistances();
                          line.userData = { isCable: true, breakerId: obj.uuid, targetId: id };
                          this.breakerCableGroup.add(line);
                          this.cableMaterials.push(material);
                      });
                  });
                  this.breakerCableGroup.visible = this.cablesVisible;
                  this.updateCableToggleButton();
              }

            updateLabelScale(val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.labelScale = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateLabelTextColor(val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.textColor = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateLabelOffset(axis, val) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                if(!this.selectedObject.userData.labelOffset) this.selectedObject.userData.labelOffset = {...CONFIG.defaultLabelOffset};
                this.selectedObject.userData.labelOffset[axis] = val;
                this.addLabel(this.selectedObject, this.selectedObject.userData.labelText);
                this.stateManager.snapshot();
            }

            updateFurnitureScale(axis, val) {
                if(!this.selectedObject || !this.selectedObject.userData.isFurniture || isNaN(val)) return;
                const safeVal = Math.max(0.2, val);
                this.selectedObject.scale[axis] = safeVal;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.updateStats();
                this.refreshFurnitureUI(this.selectedObject);
            }

            updateFurnitureRotation(deg) {
                if(!this.selectedObject || !this.selectedObject.userData.isFurniture || isNaN(deg)) return;
                const rad = THREE.MathUtils.degToRad(deg);
                this.selectedObject.rotation.y = rad;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.refreshFurnitureUI(this.selectedObject);
            }

            toggleSelectedLabel() {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                this.selectedObject.userData.labelVisible = !(this.selectedObject.userData.labelVisible !== false);
                this.updateLabelVisibility(this.selectedObject);
                this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            toggleDoorLabel() {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                if(!this.supportsDoorBadge(this.selectedObject)) return;
                this.selectedObject.userData.doorLabelVisible = !(this.selectedObject.userData.doorLabelVisible !== false);
                this.refreshDoorLabels(this.selectedObject);
                this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            toggleAllLabels() {
                this.labelsVisible = !this.labelsVisible;
                this.updateAllLabelVisibility();
                if(this.selectedObject && !this.selectedObject.userData.isFurniture) this.refreshLabelUI(this.selectedObject);
                this.stateManager.snapshot();
            }

            updateLabelVisibility(obj) {
                const label = obj.getObjectByName('Label');
                if(label) label.visible = this.labelsVisible && obj.userData.labelVisible !== false;
            }

            updateAllLabelVisibility() {
                this.scene.traverse(o => {
                    if(o.userData && o.userData.type && !o.userData.isFurniture) {
                        this.updateLabelVisibility(o);
                    }
                });
            }

            getTargetRoom() {
                if(!this.selectedObject) return null;
                return this.selectedObject.userData.isFurniture ? this.selectedObject.parent : this.selectedObject;
            }

            addFurnitureFromMenu() {
                const target = this.getTargetRoom();
                if(!target || !target.getObjectByName || target.userData.type !== 'Chambre') { this.showToast('Sélectionnez une chambre', 'error'); return; }
                const type = document.getElementById('furnitureSelector').value;
                const factory = FurnitureFactory[type];
                if(!factory) { this.showToast('Objet inconnu', 'error'); return; }
                let container = target.getObjectByName('Furniture');
                if(!container) { container = new THREE.Group(); container.name = 'Furniture'; target.add(container); }
                const item = factory();
                item.position.set(0, item.userData.defaultY || 0, 0);
                this.applyStoredOpacityToObject(item);
                  container.add(item);
                  this.snapObject(item);
                  this.refreshDoorLabels(target);
                  this.selectObject(item);
                  this.stateManager.snapshot();
                  this.updateBreakerCables();
                  this.refreshBreakerUI(this.selectedObject);
                  this.showToast(`${item.userData.name} ajouté`, 'success');
              }

            removeFurnitureFromMenu() {
                const target = this.getTargetRoom();
                if(!target || target.userData.type !== 'Chambre') { this.showToast('Sélectionnez une chambre', 'error'); return; }
                const type = document.getElementById('furnitureSelector').value;
                const group = target.getObjectByName('Furniture');
                if(!group) { this.showToast('Aucun mobilier', 'error'); return; }
                const isDoorType = ['door', 'frenchDoor', 'wcDoor'].includes(type);
                for(let i = group.children.length - 1; i >=0; i--) {
                    if(group.children[i].userData.type === type) {
                          group.remove(group.children[i]);
                          this.refreshDoorLabels(target, !isDoorType);
                          this.selectObject(target);
                          this.stateManager.snapshot();
                          this.updateBreakerCables();
                          this.showToast('Objet retiré', 'info');
                          return;
                      }
                }
                this.showToast('Aucun objet de ce type', 'error');
            }

            // --- SNAP & CONTRAINTES ---
            snapWcDoorToInnerWall(obj) {
                const room = obj.parent;
                if(!room) return false;
                const furniture = room.getObjectByName('Furniture');
                const innerWalls = furniture ? furniture.children.filter(c => c.userData?.type === 'innerWall') : [];

                if(innerWalls.length === 0) return false;

                let closestWall = null; let minDist = Infinity;
                innerWalls.forEach(wall => {
                    const dist = wall.position.distanceTo(obj.position);
                    if(dist < minDist) { minDist = dist; closestWall = wall; }
                });
                if(!closestWall) return false;

                const wallDims = closestWall.userData?.dims || { x: 0.2, z: 3 };
                const doorDims = obj.userData?.dims || { x: 0.9, z: 0.3 };
                const rotY = closestWall.rotation?.y || 0;
                const wallLength = Math.abs(Math.cos(rotY)) > 0.5 ? wallDims.z : wallDims.x;
                const halfLength = wallLength / 2 - (doorDims.x / 2);

                if(Math.abs(Math.cos(rotY)) > 0.5) {
                    // Mur orienté Nord/Sud : épaisseur sur X
                    const offset = (wallDims.x / 2) + (doorDims.z / 2) + 0.02;
                    const direction = Math.sign(obj.position.x - closestWall.position.x) || 1;
                    obj.position.x = closestWall.position.x + direction * offset;
                    obj.position.z = THREE.MathUtils.clamp(obj.position.z, closestWall.position.z - halfLength, closestWall.position.z + halfLength);
                    obj.rotation.y = 0;
                } else {
                    // Mur orienté Est/Ouest : épaisseur sur Z
                    const offset = (wallDims.z / 2) + (doorDims.z / 2) + 0.02;
                    const direction = Math.sign(obj.position.z - closestWall.position.z) || 1;
                    obj.position.z = closestWall.position.z + direction * offset;
                    obj.position.x = THREE.MathUtils.clamp(obj.position.x, closestWall.position.x - halfLength, closestWall.position.x + halfLength);
                    obj.rotation.y = Math.PI / 2;
                }
                return true;
            }

            snapObject(obj) {
                if (obj.userData.isFurniture) {
                    // 1. Gestion de la hauteur : déplacement vertical autorisé mais limité à la pièce
                    const minY = 0;
                    const maxY = CONFIG.floorHeight * 0.99;
                    obj.position.y = THREE.MathUtils.clamp(obj.position.y, minY, maxY);

                    const isWcDoor = obj.userData.type === 'wcDoor';

                    // 2. LOGIQUE "AIMANT" MUR (Porte & Fenêtre)
                    if (obj.userData.isWallMounted && !isWcDoor) {
                        const parent = obj.parent; // Le groupe Chambre
                        // Si la chambre est redimensionnée, on adapte le calcul
                        const w = (CONFIG.roomWidth * parent.scale.x) / 2;
                        const d = (CONFIG.roomDepth * parent.scale.z) / 2;
                        const margin = 0.15;

                        const distN = Math.abs(obj.position.z - (-d)); // Nord
                        const distS = Math.abs(obj.position.z - d);    // Sud
                        const distE = Math.abs(obj.position.x - w);    // Est
                        const distW = Math.abs(obj.position.x - (-w)); // Ouest

                        const min = Math.min(distN, distS, distE, distW);

                        if(min === distN) { // Mur Nord
                            obj.position.z = -d + margin; obj.rotation.y = 0;
                            obj.position.x = Math.max(-w+0.8, Math.min(w-0.8, obj.position.x));
                        } else if (min === distS) { // Mur Sud
                            obj.position.z = d - margin; obj.rotation.y = 0;
                            obj.position.x = Math.max(-w+0.8, Math.min(w-0.8, obj.position.x));
                        } else if (min === distE) { // Mur Est
                            obj.position.x = w - margin; obj.rotation.y = Math.PI/2;
                            obj.position.z = Math.max(-d+0.8, Math.min(d-0.8, obj.position.z));
                        } else { // Mur Ouest
                            obj.position.x = -w + margin; obj.rotation.y = Math.PI/2;
                            obj.position.z = Math.max(-d+0.8, Math.min(d-0.8, obj.position.z));
                        }

                        if(obj.userData.wallOffset) {
                            const dir = new THREE.Vector3(
                                min === distE ? 1 : min === distW ? -1 : 0,
                                0,
                                min === distS ? 1 : min === distN ? -1 : 0
                            );
                            obj.position.addScaledVector(dir, obj.userData.wallOffset);
                        }

                        return;
                    }

                    if (isWcDoor && obj.userData.isWallMounted) {
                        const snapped = this.snapWcDoorToInnerWall(obj);
                        if(snapped) return;
                    }

                    // 3. MEUBLES CLASSIQUES (dont porte WC placée librement)
                    if(this.control.mode === 'translate') {
                        obj.position.x = Math.round(obj.position.x / 0.1) * 0.1;
                        obj.position.z = Math.round(obj.position.z / 0.1) * 0.1;
                    }

                    // CONFINEMENT (Reste dans la pièce)
                    const parent = obj.parent;
                    const roomW = CONFIG.roomWidth * parent.scale.x;
                    const roomD = CONFIG.roomDepth * parent.scale.z;
                    const padding = 0.2;
                    const dimsX = (obj.userData.dims?.x || 0.5) * (obj.scale?.x || 1);
                    const dimsZ = (obj.userData.dims?.z || 0.5) * (obj.scale?.z || 1);
                    const rotY = obj.rotation?.y || 0;
                    const cosY = Math.abs(Math.cos(rotY));
                    const sinY = Math.abs(Math.sin(rotY));

                    // Rayon projeté sur les axes après rotation (AABB du rectangle tourné)
                    const halfX = (dimsX * cosY + dimsZ * sinY) / 2;
                    const halfZ = (dimsZ * cosY + dimsX * sinY) / 2;

                    const minX = - (roomW / 2) + halfX + padding; const maxX = (roomW / 2) - halfX - padding;
                    const minZ = - (roomD / 2) + halfZ + padding; const maxZ = (roomD / 2) - halfZ - padding;

                    obj.position.x = Math.max(minX, Math.min(maxX, obj.position.x));
                    obj.position.z = Math.max(minZ, Math.min(maxZ, obj.position.z));

                  } else {
                    // 4. DÉPLACEMENT STRUCTURE
                    if(this.control.mode === 'translate') {
                        obj.position.x = Math.round(obj.position.x / CONFIG.gridSize) * CONFIG.gridSize;
                        obj.position.z = Math.round(obj.position.z / CONFIG.gridSize) * CONFIG.gridSize;
                        const yBase = this.getFloorY(obj.userData.floor || 0) + this.getTypeYOffset(obj.userData.type);
                        obj.position.y = yBase;
                      } else if (this.control.mode === 'rotate') {
                          obj.rotation.x = 0; obj.rotation.z = 0;
                          obj.rotation.y = Math.round(obj.rotation.y / (Math.PI/2)) * (Math.PI/2);
                      }
                  }
                  if(obj.userData?.isBreaker || obj.userData?.type === 'Chambre') this.updateBreakerCables();
                  if(obj === this.selectedObject) this.refreshStructureDimensionsUI(obj);
              }

            // --- EVENTS ---
            onPointerDown(event) {
                if(this.isGlobalView) return;
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.pointer, this.camera);
                
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);
                let target = null;

                // --- PASSE 1 : RECHERCHE DE MEUBLES (PRIORITÉ ABSOLUE) ---
                for (let hit of intersects) {
                    if (hit.object.type === 'Sprite' || hit.object.name === 'Ground' || hit.object.userData?.isCable) continue;
                    
                    let node = hit.object;
                    let foundFurniture = null;
                    while(node && node.parent) {
                        if(node.userData && node.userData.isFurniture) {
                            let root = node; while(root.parent && root.parent !== this.scene) root = root.parent;
                            if(root.userData.floor === this.floors.current) foundFurniture = node;
                            break;
                        }
                        node = node.parent;
                    }
                    if(foundFurniture) {
                        target = foundFurniture;
                        break; // Trouvé ! On arrête tout de suite
                    }
                }

                // --- PASSE 2 : SI AUCUN MEUBLE, RECHERCHE DE STRUCTURE ---
                if (!target) {
                    for (let hit of intersects) {
                        if (hit.object.type === 'Sprite' || hit.object.name === 'Ground' || hit.object.userData?.isCable) continue;
                        let node = hit.object;
                        let foundStructure = null;
                        while(node && node.parent) {
                            if(node.parent === this.scene && node.userData.type) {
                                if(node.userData.floor === this.floors.current) foundStructure = node;
                                break;
                            }
                            node = node.parent;
                        }
                        if(foundStructure) {
                            target = foundStructure;
                            break;
                        }
                    }
                }

                if(this.selectionLocked && target !== this.selectedObject) return;
                this.selectObject(target);
            }

              selectObject(obj) {
                  if(!this.multiSelectEnabled) {
                      this.multiSelection.clear();
                  } else if(obj) {
                      if(this.multiSelection.has(obj)) this.multiSelection.delete(obj); else this.multiSelection.add(obj);
                  }

                  this.selectionLocked = this.multiSelectEnabled ? false : !!obj;
                  this.selectedObject = obj;
                  const panel = document.getElementById('propPanel');
                  const dupInput = document.getElementById('duplicateFloorTarget');

                  if (obj) {
                    this.control.attach(obj);
                    panel.classList.remove('opacity-50', 'pointer-events-none', 'scale-95');
                    panel.classList.add('opacity-100', 'scale-100');
                    document.getElementById('propName').value = obj.userData.name || '';
                    this.setColorTarget(this.colorTarget);
                    this.refreshWallUI(obj);
                    this.refreshOpacityUI(obj);

                    this.control.showX = this.control.showY = this.control.showZ = true;
                    if(obj.userData.isFurniture) {
                        document.getElementById('propTitle').innerText = "MOBILIER";
                        document.getElementById('colorSection').classList.remove('hidden');
                        document.getElementById('sizeSection').classList.add('hidden');
                          document.getElementById('labelSection').classList.add('hidden');
                          document.getElementById('furnitureSection').classList.add('hidden');
                          document.getElementById('furnitureTransformSection').classList.remove('hidden');
                          this.refreshFurnitureUI(obj);
                          this.refreshBreakerUI(obj);
                      } else {
                          document.getElementById('propTitle').innerText = "PROPRIÉTÉS";
                          document.getElementById('colorSection').classList.remove('hidden');
                          document.getElementById('sizeSection').classList.remove('hidden');
                          document.getElementById('labelSection').classList.remove('hidden');
                          document.getElementById('furnitureSection').classList.remove('hidden');
                          document.getElementById('furnitureTransformSection').classList.add('hidden');
                          this.refreshLabelUI(obj);
                          this.refreshBreakerUI(null);
                      }
                      this.updateColorControlsForSelection(obj);
                      this.refreshStructureDimensionsUI(obj);
                      if(dupInput) dupInput.value = obj.userData.floor ?? this.floors.current;
                      } else {
                    this.control.detach();
                    panel.classList.add('opacity-50', 'pointer-events-none', 'scale-95');
                    document.getElementById('furnitureTransformSection').classList.add('hidden');
                    this.refreshBreakerUI(null);
                    this.refreshOpacityUI(null);
                    this.refreshWallUI(null);
                    this.updateColorControlsForSelection(null);
                    this.refreshStructureDimensionsUI(null);
                    if(dupInput) dupInput.value = this.floors.current;
                }
                  this.updateMultiSelectionUI();
                  this.updateSelectionChips();
                  this.updateSelectionLockUI();
              }

            // ... Rest (setMode, changeFloor, etc) same as before ...
            setMode(mode) {
                this.control.setMode(mode);
                document.querySelectorAll('#toolTranslate, #toolRotate, #toolScale').forEach(el => el.classList.remove('text-blue-600', 'bg-blue-50'));
                const id = 'tool' + mode.charAt(0).toUpperCase() + mode.slice(1);
                document.getElementById(id).classList.add('text-blue-600', 'bg-blue-50');
                this.updateSelectionChips();
            }

            changeFloor(delta) {
                const next = this.floors.current + delta;
                if (next < 0 || next > this.floors.max) return;
                this.floors.current = next;
                this.updateFloorVisibility(); this.updateUI(); this.selectObject(null);
                this.gridHelper.position.y = this.getFloorY(this.floors.current);
                this.updateSelectionChips();
            }

            addFloor() { this.floors.max++; this.changeFloor(1); this.showToast(`Étage ${this.floors.current} créé`, 'success'); this.stateManager.snapshot(); }

            cloneCurrentFloor() {
                const currentObjects = [];
                this.scene.traverse(obj => {
                    if(obj.userData && obj.userData.floor === this.floors.current && obj.userData.type) currentObjects.push(obj);
                });
                if(currentObjects.length === 0) { this.showToast('Étage vide', 'error'); return; }
                this.addFloor();
                currentObjects.forEach(original => {
                    const furnitureList = [];
                    const fGroup = original.getObjectByName('Furniture');
                    if(fGroup) {
                        fGroup.children.forEach(c => furnitureList.push({
                            type: c.userData.type,
                            pos: c.position.toArray(),
                            rot: [c.rotation.x, c.rotation.y, c.rotation.z],
                            scale: c.scale.toArray(),
                            userData: JSON.parse(JSON.stringify(c.userData))
                        }));
                    }
                    if(original.userData.type === 'Exterieur') return;
                    const baseType = original.userData.type === 'Chambre' ? 'room' : original.userData.type === 'Couloir' ? 'corridor' : (original.userData.type === 'Escalier' ? 'stairs' : 'generic');
                    const clone = this.createBlock(baseType, furnitureList);
                      if(clone) {
                          clone.position.x = original.position.x; clone.position.z = original.position.z; clone.rotation.copy(original.rotation);
                          clone.userData = JSON.parse(JSON.stringify(original.userData));
                          clone.userData.floor = this.floors.current;
                          if(clone.userData.type === 'Chambre') this.ensureRoomId(clone, true);
                          this.ensureLabelDefaults(clone);
                          if(clone.userData.type === 'Chambre') {
                              this.setRoomWallColor(clone, clone.userData.wallColor || '#6366f1');
                              this.applyRoomWallState(clone);
                          }
                          if(clone.userData.labelText) this.addLabel(clone, clone.userData.labelText);
                      }
                });
                this.stateManager.snapshot(); this.updateStats();
            }

            updateFloorVisibility() {
                this.scene.traverse(obj => {
                    if(obj.userData && obj.userData.type) {
                        const isCurrent = obj.userData.floor === this.floors.current;
                        if(this.isGlobalView) { obj.visible = true; this.setOpacity(obj, 1); }
                        else {
                            if (obj.userData.floor > this.floors.current) obj.visible = false;
                            else if (isCurrent) { obj.visible = true; this.setOpacity(obj, 1); }
                            else { obj.visible = true; this.setOpacity(obj, 0.1); }
                        }
                    }
                });
            }

            getEffectiveOpacityTarget(obj) {
                if(!obj) return 'object';
                return obj.userData?.type === 'Chambre' ? this.opacityTarget : 'object';
            }

            getOpacityTargets(obj, target = null) {
                if(!obj) return [];
                const scope = target || this.getEffectiveOpacityTarget(obj);
                if(obj.userData?.type === 'Chambre') {
                    if(scope === 'furniture') {
                        const targets = new Set();
                        const furniture = obj.getObjectByName('Furniture');
                        if(furniture) targets.add(furniture);

                        obj.traverse(child => {
                            if(child === obj) return;
                            if(child.name === 'RoomShell' || child.name === 'StructureHitbox' || child.name === 'Label') return;
                            if(child.userData?.isFurniture) targets.add(child);
                        });

                        return Array.from(targets);
                    }
                    const shell = obj.getObjectByName('RoomShell');
                    return shell ? [shell] : [obj];
                }
                return [obj];
            }

            restoreMaterialOpacity(obj) {
                if(!obj) return;
                obj.traverse(child => {
                    if(!child.isMesh) return;
                    const reset = (mat) => {
                        if(!mat) return;
                        if(!mat.userData) mat.userData = {};
                        if(mat.userData.baseOpacity === undefined) mat.userData.baseOpacity = mat.opacity ?? 1;
                        if(mat.userData.baseTransparent === undefined) mat.userData.baseTransparent = mat.transparent ?? false;
                        mat.opacity = mat.userData.baseOpacity;
                        mat.transparent = mat.userData.baseTransparent;
                    };
                    Array.isArray(child.material) ? child.material.forEach(reset) : reset(child.material);
                });
            }

            setOpacity(obj, val) {
                obj.traverse(child => {
                    if(child.isMesh) {
                        const applyToMaterial = (mat) => {
                            if(!mat.userData) mat.userData = {};
                            if(mat.userData.baseOpacity === undefined) {
                                mat.userData.baseOpacity = mat.opacity ?? 1;
                                mat.userData.baseTransparent = mat.transparent ?? false;
                            }

                            if(val === 1) {
                                mat.opacity = mat.userData.baseOpacity;
                                mat.transparent = mat.userData.baseTransparent;
                            } else {
                                mat.transparent = true;
                                mat.opacity = val;
                            }
                        };

                        if(Array.isArray(child.material)) child.material.forEach(applyToMaterial);
                        else applyToMaterial(child.material);
                    }
                    if(child.name === 'Label') child.visible = val > 0.5 && this.labelsVisible && child.parent?.userData.labelVisible !== false;
                });
            }

            computeObjectOpacity(obj, target = null) {
                const values = [];
                this.getOpacityTargets(obj, target).forEach(t => {
                    t?.traverse(child => {
                        if(!child.isMesh) return;
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(mat => {
                            if(!mat) return;
                            const base = mat.userData?.baseOpacity ?? mat.opacity ?? 1;
                            values.push(base);
                        });
                    });
                });
                if(values.length === 0) return 1;
                const avg = values.reduce((a,b) => a + b, 0) / values.length;
                return THREE.MathUtils.clamp(avg, 0.05, 1);
            }

            getStoredOpacity(obj, target = null) {
                if(!obj) return 1;
                const scope = target || this.getEffectiveOpacityTarget(obj);
                if(obj.userData?.type === 'Chambre') {
                    if(scope === 'furniture') return obj.userData.furnitureOpacity ?? 1;
                    return obj.userData.wallOpacity ?? obj.userData.opacity ?? 1;
                }
                return obj.userData.opacity ?? this.computeObjectOpacity(obj, scope);
            }

            applyStoredOpacityToObject(obj, target = null) {
                if(!obj) return;
                const scopes = target ? [target] : (obj.userData?.type === 'Chambre' ? ['walls', 'furniture'] : ['object']);
                scopes.forEach(scope => {
                    const currentOpacity = this.getStoredOpacity(obj, scope);
                    if(obj.userData.opacity === undefined && scope === 'object') obj.userData.opacity = this.computeObjectOpacity(obj, scope);
                    this.getOpacityTargets(obj, scope).forEach(targetObj => {
                        targetObj?.traverse(child => {
                            if(!child.isMesh) return;
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if(!mat) return;
                                if(!mat.userData) mat.userData = {};
                                if(mat.userData.baseTransparent === undefined) mat.userData.baseTransparent = mat.transparent ?? false;
                                mat.userData.baseOpacity = currentOpacity;
                                mat.transparent = mat.userData.baseTransparent || currentOpacity < 1;
                                mat.opacity = currentOpacity;
                            });
                        });
                    });
                });
            }

            refreshOpacityUI(obj) {
                const slider = document.getElementById('opacityInput');
                const label = document.getElementById('opacityValue');
                const activeTarget = this.getEffectiveOpacityTarget(obj);
                const value = obj ? this.getStoredOpacity(obj, activeTarget) : 1;
                if(slider) slider.value = value;
                if(label) label.textContent = `${Math.round(value * 100)}%`;
                this.updateOpacityTargetUI(obj);
            }

            updateOpacityTargetUI(obj) {
                const group = document.getElementById('opacityTargetGroup');
                const wallBtn = document.getElementById('opacityTargetWalls');
                const furnitureBtn = document.getElementById('opacityTargetFurniture');
                const isRoom = obj?.userData?.type === 'Chambre';

                if(group) group.classList.toggle('hidden', !isRoom);
                if(!wallBtn || !furnitureBtn) return;

                furnitureBtn.classList.toggle('opacity-50', !isRoom);
                furnitureBtn.classList.toggle('pointer-events-none', !isRoom);

                const active = isRoom ? this.opacityTarget : 'walls';
                const setState = (btn, enabled) => {
                    btn.classList.toggle('bg-white', enabled);
                    btn.classList.toggle('shadow-sm', enabled);
                    btn.classList.toggle('text-gray-800', enabled);
                    btn.classList.toggle('text-gray-400', !enabled);
                };

                setState(wallBtn, active === 'walls');
                setState(furnitureBtn, active === 'furniture');
            }

            setOpacityTarget(target) {
                if(!this.selectedObject || this.selectedObject.userData?.type !== 'Chambre') return;
                this.opacityTarget = target === 'furniture' ? 'furniture' : 'walls';
                this.refreshOpacityUI(this.selectedObject);
            }

            updateSelectionOpacity(val, snapshot = true) {
                if(!this.selectedObject || isNaN(val)) return;
                const clamped = THREE.MathUtils.clamp(val, 0.05, 1);
                const target = this.getEffectiveOpacityTarget(this.selectedObject);

                if(this.selectedObject.userData?.type === 'Chambre') {
                    if(target === 'furniture') this.selectedObject.userData.furnitureOpacity = clamped;
                    else { this.selectedObject.userData.wallOpacity = clamped; this.selectedObject.userData.opacity = clamped; }
                } else {
                    this.selectedObject.userData.opacity = clamped;
                }

                this.applyStoredOpacityToObject(this.selectedObject, target);
                this.setOpacity(this.selectedObject, 1);
                this.refreshOpacityUI(this.selectedObject);
                if(snapshot) this.stateManager.snapshot();
            }

            setGlobalView(isGlobal) {
                this.isGlobalView = isGlobal;
                document.getElementById('viewFloor').classList.toggle('active', !isGlobal);
                document.getElementById('viewGlobal').classList.toggle('active', isGlobal);
                document.getElementById('viewGlobal').classList.toggle('bg-white/50', !isGlobal);
                this.selectObject(null); this.control.enabled = !isGlobal; this.gridHelper.visible = !isGlobal;
                if(isGlobal) { this.camera.position.set(50, 50, 50); this.camera.lookAt(0, (this.floors.max * (CONFIG.floorHeight + CONFIG.floorGap))/2, 0); }
                else { this.changeFloor(0); }
                document.getElementById('viewHint').textContent = isGlobal ? 'Vue globale multi-niveaux' : 'Exploration étage en cours';
                this.updateFloorVisibility();
                this.updateSelectionChips();
            }

            applyPresetRotation(direction) {
                if(!this.selectedObject) return;
                const angleDeg = parseFloat(document.getElementById('rotationAngleSelect').value) || 0;
                if(angleDeg === 0) return;
                const axis = document.getElementById('rotationAxisSelect').value || 'y';
                const delta = (angleDeg * Math.PI / 180) * (direction === 'cw' ? 1 : -1);
                if(!['x','y','z'].includes(axis)) return;
                this.selectedObject.rotation[axis] += delta;
                this.snapObject(this.selectedObject);
                this.stateManager.snapshot();
                this.updateSelectionChips();
                this.showToast(`Rotation ${direction === 'cw' ? '+' : '-'}${angleDeg}°`, 'info');
            }

            setColorTarget(target) {
                this.colorTarget = target;
                const blockBtn = document.getElementById('targetBlock');
                const labelBtn = document.getElementById('targetLabel');
                if(blockBtn && labelBtn) {
                    blockBtn.classList.toggle('bg-white', target === 'block');
                    blockBtn.classList.toggle('shadow-sm', target === 'block');
                    blockBtn.classList.toggle('text-gray-800', target === 'block');
                    blockBtn.classList.toggle('text-gray-400', target !== 'block');
                    labelBtn.classList.toggle('bg-white', target === 'label');
                    labelBtn.classList.toggle('shadow-sm', target === 'label');
                    labelBtn.classList.toggle('text-gray-800', target === 'label');
                    labelBtn.classList.toggle('text-gray-400', target !== 'label');
                }
                const badge = document.getElementById('colorTargetBadge');
                if(badge) {
                    badge.innerHTML = `<i data-lucide="${target === 'block' ? 'brick-wall' : 'sticky-note'}" size="14"></i>${target === 'block' ? 'Murs' : 'Étiquette'}`;
                    lucide.createIcons({ root: badge });
                }
                this.updateSelectionChips();
            }

            updateColorControlsForSelection(obj) {
                const colorSection = document.getElementById('colorSection');
                if(!colorSection) return;

                const supportsLabel = !!obj && !obj.userData?.isFurniture;
                colorSection.classList.toggle('hidden', !obj);

                const labelBtn = document.getElementById('targetLabel');
                if(labelBtn) {
                    labelBtn.classList.toggle('opacity-50', !supportsLabel);
                    labelBtn.classList.toggle('pointer-events-none', !supportsLabel);
                }

                if(!supportsLabel && this.colorTarget === 'label') this.setColorTarget('block');
            }

            formatFloorLabel(floor) {
                return floor === 0 ? 'RDC' : `Étage ${floor}`;
            }

            updateSelectionChips() {
                const selectionChip = document.getElementById('selectionChip');
                const summary = document.getElementById('selectionSummary');
                const floorBadge = document.getElementById('floorContextBadge');
                const modeChip = document.getElementById('modeChip');
                if(modeChip) modeChip.textContent = `Mode ${this.control?.getMode() === 'translate' ? 'déplacement' : this.control?.getMode() === 'rotate' ? 'rotation' : 'échelle'}`;
                if(!selectionChip || !summary || !floorBadge) return;
                if(this.selectedObject) {
                    const type = this.selectedObject.userData.isFurniture ? 'Mobilier' : (this.selectedObject.userData.type || 'Objet');
                    const label = this.selectedObject.userData.name || this.selectedObject.userData.labelText || 'Sans nom';
                    selectionChip.textContent = `${type}`;
                    selectionChip.className = 'pill bg-emerald-600/90';
                    summary.textContent = `${label} • ${this.formatFloorLabel(this.selectedObject.userData.floor || 0)}`;
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.selectedObject.userData.floor || 0)}`;
                    lucide.createIcons({ root: floorBadge });
                } else {
                    selectionChip.textContent = 'Aucune sélection';
                    selectionChip.className = 'pill bg-slate-500/80';
                    summary.textContent = 'Inspecteur inactif';
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.floors.current)}`;
                    lucide.createIcons({ root: floorBadge });
                }
                this.updateSelectionLockUI();
            }

            updateSelectionLockUI() {
                const btn = document.getElementById('selectionLockBtn');
                if(!btn) return;
                const icon = btn.querySelector('i');
                const label = btn.querySelector('span');
                const locked = this.selectionLocked && !!this.selectedObject;

                btn.disabled = this.multiSelectEnabled;
                btn.classList.toggle('opacity-50', this.multiSelectEnabled);
                btn.classList.toggle('pointer-events-none', this.multiSelectEnabled);

                btn.classList.toggle('bg-emerald-600/90', locked);
                btn.classList.toggle('bg-slate-700/80', !locked);
                btn.title = locked ? 'Déverrouiller la sélection' : 'Verrouiller la sélection';

                if(icon) icon.setAttribute('data-lucide', locked ? 'lock' : 'unlock');
                if(label) label.textContent = locked ? 'Sélection verrouillée' : 'Sélection libre';

                lucide.createIcons({ root: btn });
            }

            toggleSelectionLock() {
                if(!this.selectedObject) {
                    this.selectionLocked = false;
                    this.updateSelectionLockUI();
                    this.showToast('Sélectionnez un objet avant de verrouiller.', 'info');
                    return;
                }
                this.selectionLocked = !this.selectionLocked;
                this.updateSelectionLockUI();
                this.showToast(this.selectionLocked ? 'Sélection verrouillée' : 'Sélection déverrouillée', 'info');
            }

            setMultiSelectionEnabled(enabled) {
                this.multiSelectEnabled = enabled;
                if(!enabled) this.multiSelection.clear();
                else if(this.selectedObject && !this.selectedObject.userData.isFurniture) this.multiSelection.add(this.selectedObject);
                this.selectionLocked = false;
                this.updateMultiSelectionUI();
                this.updateSelectionLockUI();
                this.showToast(enabled ? 'Sélection multiple activée' : 'Sélection multiple désactivée', 'info');
            }

            updateMultiSelectionUI() {
                const hint = document.getElementById('multiSelectHint');
                if(!hint) return;
                const count = Array.from(this.multiSelection).filter(obj => obj?.userData && !obj.userData.isFurniture).length;
                const label = this.multiSelectEnabled ? `${count} élément(s) prêts` : 'Sélection classique';
                hint.querySelector('span').textContent = label;
                const icon = hint.querySelector('i');
                if(icon) icon.setAttribute('data-lucide', this.multiSelectEnabled ? 'check-square' : 'list');
                lucide.createIcons({ root: hint });
            }

            setRoomWallColor(room, hex) {
                if(!room || room.userData.type !== 'Chambre') return;
                const shell = room.getObjectByName('RoomShell');
                if(shell) {
                    shell.traverse(child => {
                        if(child.isMesh && child.userData?.isWall) child.material.color.set(hex);
                    });
                }
                room.userData.wallColor = hex;
            }

            applyColor(hex) {
                if(!this.selectedObject) return;
                const obj = this.selectedObject;
                this.ensureLabelDefaults(obj);
                const target = (!obj.userData.isFurniture) ? this.colorTarget : 'block';
                if(target === 'block') {
                    if(obj.userData.type === 'Chambre') this.setRoomWallColor(obj, hex);
                    else {
                        const shell = obj.getObjectByName('RoomShell');
                        if(shell) {
                            shell.traverse(child => { if(child.isMesh) child.material.color.set(hex); });
                        } else { obj.traverse(c => { if(c.isMesh) c.material.color.set(hex); }); }
                    }
                } else {
                    obj.userData.labelColor = hex; this.addLabel(obj, obj.userData.labelText);
                }
                this.stateManager.snapshot();
            }

            updateObjectName() {
                if(!this.selectedObject) return;
                const val = document.getElementById('propName').value;
                if(val) {
                    this.selectedObject.userData.name = val;
                    if(this.selectedObject.userData.isFurniture) { }
                    else {
                        const numericLabel = val.match(/\d+/)?.[0] || val;
                        this.selectedObject.userData.labelText = numericLabel;
                        this.addLabel(this.selectedObject, numericLabel);
                    }
                    this.refreshDoorLabels(this.selectedObject);
                    this.showToast('Nom mis à jour', 'success'); this.stateManager.snapshot();
                }
            }

            resizeSelection(size) {
                if(!this.selectedObject || this.selectedObject.userData.isFurniture) return;
                const scales = { 'S': [0.8, 1, 0.8], 'M': [1, 1, 1], 'L': [1.5, 1, 1.2] };
                const s = scales[size];
                this.selectedObject.scale.set(s[0], s[1], s[2]);
                this.snapObject(this.selectedObject);
                this.refreshStructureDimensionsUI(this.selectedObject);
                this.stateManager.snapshot(); this.updateStats();
            }

            duplicateSelection() {
                const targets = this.getDuplicationTargets();
                if(targets.length === 0) { this.showToast('Aucun objet sélectionné à dupliquer', 'info'); return; }
                const dupInput = document.getElementById('duplicateFloorTarget');
                let targetFloor = this.floors.current;
                if(dupInput) {
                    const parsed = parseInt(dupInput.value);
                    if(!isNaN(parsed)) targetFloor = Math.max(0, parsed);
                }
                if(targetFloor > this.floors.max) { this.floors.max = targetFloor; this.updateUI(); }

                let lastClone = null;
                targets.forEach(original => {
                    if(original.userData?.isFurniture) {
                        if(!this.multiSelectEnabled) lastClone = this.duplicateFurnitureObject(original) || lastClone;
                    } else {
                        lastClone = this.duplicateStructureObject(original, targetFloor) || lastClone;
                    }
                });

                this.updateFloorVisibility();
                this.updateBreakerCables();
                this.stateManager.snapshot(); this.updateStats();
                if(lastClone) this.selectObject(lastClone);
                const label = targets.length > 1 ? `${targets.length} objets` : 'Objet';
                this.showToast(`${label} dupliqué(s) vers ${this.formatFloorLabel(targetFloor)}`, 'success');
            }

            getDuplicationTargets() {
                if(this.multiSelectEnabled && this.multiSelection.size > 0) {
                    return Array.from(this.multiSelection).filter(obj => obj?.userData && !obj.userData.isFurniture);
                }
                return this.selectedObject ? [this.selectedObject] : [];
            }

            duplicateFurnitureObject(original) {
                if(!original?.userData?.isFurniture) return null;
                const clone = original.clone();
                clone.position.x += 0.5; clone.position.z += 0.5;
                clone.userData.opacity = original.userData.opacity ?? this.computeObjectOpacity(original);
                this.applyStoredOpacityToObject(clone);
                this.restoreMaterialOpacity(clone);
                this.setOpacity(clone, 1);
                original.parent.add(clone);
                return clone;
            }

            duplicateStructureObject(original, targetFloor) {
                if(!original?.userData || original.userData.isFurniture) return null;
                const furnitureList = [];
                const fGroup = original.getObjectByName('Furniture');
                if(fGroup) {
                    fGroup.children.forEach(c => furnitureList.push({
                        type: c.userData.type,
                        pos: c.position.toArray(),
                        rot: [c.rotation.x, c.rotation.y, c.rotation.z],
                        scale: c.scale.toArray(),
                        userData: JSON.parse(JSON.stringify(c.userData))
                    }));
                }
                const baseType = original.userData.type === 'Chambre' ? 'room' : original.userData.type === 'Couloir' ? 'corridor' : (original.userData.type === 'Escalier' ? 'stairs' : 'generic');
                let clone;
                if(original.userData.type === 'Exterieur') {
                    clone = this.createExterior(original.userData.element, targetFloor);
                } else {
                    clone = this.createBlock(baseType, furnitureList, targetFloor);
                }
                if(clone) {
                    const offset = targetFloor === original.userData.floor ? 2 : 0;
                    const yBase = this.getFloorY(targetFloor) + this.getTypeYOffset(clone.userData.type);
                    clone.position.set(original.position.x + offset, yBase, original.position.z + offset);
                    clone.rotation.copy(original.rotation);
                    clone.scale.copy(original.scale);
                    clone.userData = JSON.parse(JSON.stringify(original.userData));
                    clone.userData.floor = targetFloor;
                    if(clone.userData.type === 'Chambre') this.ensureRoomId(clone, true);
                    this.ensureLabelDefaults(clone);
                    if(clone.userData.type === 'Chambre') {
                        this.setRoomWallColor(clone, clone.userData.wallColor || '#6366f1');
                        this.applyRoomWallState(clone);
                    }
                    this.applyStoredOpacityToObject(clone);
                    if(!isNaN(parseInt(clone.userData.labelText))) {
                      const newNum = this.roomCounter++; clone.userData.labelText = newNum.toString(); clone.userData.name = `Chambre ${newNum}`;
                          this.addLabel(clone, clone.userData.labelText);
                      }
                      this.refreshDoorLabels(clone);
                      this.restoreMaterialOpacity(clone);
                      this.setOpacity(clone, 1);
                }
                return clone;
            }

            deleteSelection() {
                if(!this.selectedObject) return;
                const isDoorFurniture = this.selectedObject.userData.isFurniture && this.selectedObject.userData.type === 'door';
                const parentRoom = isDoorFurniture ? this.selectedObject.parent?.parent : null;

                if(this.multiSelectEnabled) this.multiSelection.delete(this.selectedObject);
                if(this.selectedObject.userData.isFurniture) this.selectedObject.parent.remove(this.selectedObject);
                else this.scene.remove(this.selectedObject);

                if(isDoorFurniture && parentRoom) this.refreshDoorLabels(parentRoom, false);
                this.selectObject(null); this.updateBreakerCables(); this.stateManager.snapshot(); this.updateStats(); this.showToast('Supprimé', 'info');
            }

            serializeScene() {
                const objects = [];
                this.scene.traverse(obj => {
                      if(obj.userData && obj.userData.type) {
                          const furniture = [];
                          const fGroup = obj.getObjectByName('Furniture');
                          if(fGroup) fGroup.children.forEach(c => furniture.push({ type: c.userData.type, pos: c.position.toArray(), rot: c.rotation.toArray(), userData: c.userData }));
                          objects.push({ type: obj.userData.type, position: obj.position.toArray(), rotation: obj.rotation.toArray(), scale: obj.scale.toArray(), userData: obj.userData, furniture: furniture });
                      }
                  });
                  return { version: 2.7, timestamp: Date.now(), roomCounter: this.roomCounter, floors: this.floors, objects: objects, labelsVisible: this.labelsVisible, breakerCablesVisible: this.cablesVisible };
              }

            saveToFile() {
                  const data = JSON.stringify(this.serializeScene(), null, 2);
                  const blob = new Blob([data], {type: 'application/json'});
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a'); a.href = url; a.download = `flexilogis_v2.7_${new Date().toISOString().slice(0,10)}.json`; a.click();
                  this.showToast('Projet sauvegardé', 'success');
              }

            loadScene(state) {
                  this.resetScene(false); this.roomCounter = state.roomCounter; this.floors = state.floors; this.labelsVisible = state.labelsVisible !== undefined ? state.labelsVisible : true; this.cablesVisible = state.breakerCablesVisible !== undefined ? state.breakerCablesVisible : true;
                  this.multiSelection.clear(); this.updateMultiSelectionUI();
                  state.objects.forEach(data => {
                      const savedCurrent = this.floors.current; this.floors.current = data.userData.floor;
                      let obj;
                    if(data.type === 'Chambre') obj = this.createBlock('room', data.furniture);
                    else if(data.type === 'Couloir') obj = this.createBlock('corridor');
                    else if(data.type === 'Zone' || data.type === 'Generic') obj = this.createBlock('generic');
                    else if(data.type === 'Escalier') obj = this.createBlock('stairs');
                    else if(data.userData?.type === 'Exterieur') {
                        const element = data.userData.element || 'pelouse';
                        if(element.startsWith('terrasse')) obj = this.createExteriorPreset('terrasse', element.split('-')[1] || 'moyenne');
                        else if(element.startsWith('parking')) obj = this.createExteriorPreset('parking', element.split('-')[1] || 'moyenne');
                        else obj = this.createExterior(element, data.userData.floor || 0);
                    }
                      if(obj) {
                          obj.position.fromArray(data.position); obj.rotation.fromArray(data.rotation); obj.scale.fromArray(data.scale); obj.userData = data.userData;
                          const yBase = this.getFloorY(obj.userData.floor || 0) + this.getTypeYOffset(obj.userData.type);
                          obj.position.y = yBase;
                          if(!obj.userData.baseSize) this.captureBaseSize(obj);
                          if(obj.userData.type === 'Chambre') this.ensureRoomId(obj);
                          this.ensureLabelDefaults(obj);
                          if(obj.userData.labelText) this.addLabel(obj, obj.userData.labelText);
                          if(obj.userData.type === 'Chambre') {
                              this.setRoomWallColor(obj, obj.userData.wallColor || '#6366f1');
                              this.applyRoomWallState(obj);
                          }
                        this.applyStoredOpacityToObject(obj);
                        this.refreshDoorLabels(obj);
                        if(obj.userData.labelColor) this.selectedObject = obj;
                    }
                      this.floors.current = savedCurrent;
                  });
                  this.updateFloorVisibility(); this.updateUI(); this.updateStats(); this.updateAllLabelVisibility();
                  this.updateBreakerCables();
                  this.updateSelectionChips();
              }

            loadFile(event) {
                const file = event.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => { try { this.loadScene(JSON.parse(e.target.result)); this.showToast('Chargé', 'success'); } catch(err) { console.error(err); this.showToast('Erreur', 'error'); } };
                reader.readAsText(file); event.target.value = '';
            }

            resetScene(createDefault = true) {
                  const toRemove = []; this.scene.traverse(obj => { if(obj.userData && obj.userData.type) toRemove.push(obj); });
                  toRemove.forEach(o => this.scene.remove(o));
                  if(this.breakerCableGroup) this.breakerCableGroup.clear();
                  this.cableMaterials = [];
                  this.roomCounter = 1; this.floors = { current: 0, max: 0 }; this.labelsVisible = true; this.cablesVisible = true; this.updateUI(); this.updateStats();
                  this.multiSelection.clear(); this.updateMultiSelectionUI();
                  this.updateCableToggleButton();
                  if(createDefault) { this.createBlock('room'); this.stateManager.history = []; this.stateManager.snapshot(); this.showToast('Reset', 'info'); }
              }

            updateUI() {
                document.getElementById('floorNumberDisplay').innerText = this.floors.current;
                document.getElementById('floorBadge').innerText = this.floors.current === 0 ? "RDC" : "ÉTAGE " + this.floors.current;
                document.getElementById('floorDown').disabled = this.floors.current === 0;
                document.getElementById('floorUp').disabled = this.floors.current === this.floors.max;
                const dupInput = document.getElementById('duplicateFloorTarget');
                if(dupInput) dupInput.value = this.floors.current;
                const floorBadge = document.getElementById('floorContextBadge');
                if(floorBadge) {
                    floorBadge.innerHTML = `<i data-lucide="map-pin" size="14"></i>${this.formatFloorLabel(this.floors.current)}`;
                    lucide.createIcons({ root: floorBadge });
                }
            }

            updateStats() {
                let count = 0; let area = 0;
                this.scene.traverse(obj => { if(obj.userData && obj.userData.type === 'Chambre') { count++; const base = obj.userData.baseSize || { x: 4, z: 6 }; area += (obj.scale.x * base.x) * (obj.scale.z * base.z); } });
                document.getElementById('statRooms').innerText = count; document.getElementById('statArea').innerText = Math.round(area) + " m²";
            }

            showToast(msg, type = 'success') {
                const container = document.getElementById('toast-container');
                const el = document.createElement('div'); el.className = `toast ${type}`;
                let icon = 'check-circle'; if(type==='error') icon='alert-circle'; if(type==='info') icon='info';
                el.innerHTML = `<i data-lucide="${icon}" size="18"></i> <span>${msg}</span>`;
                container.appendChild(el); lucide.createIcons({ root: el });
                setTimeout(() => { el.style.animation = 'fadeOut 0.3s forwards'; setTimeout(() => el.remove(), 300); }, 3000);
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            onKeyDown(e) {
                if(e.target.tagName === 'INPUT') return; 
                const k = e.key.toLowerCase();
                if((e.ctrlKey||e.metaKey) && k === 'z') { e.preventDefault(); this.stateManager.undo(); return; }
                if((e.ctrlKey||e.metaKey) && k === 'y') { e.preventDefault(); this.stateManager.redo(); return; }
                if(k === 'w') this.setMode('translate'); if(k === 'e') this.setMode('rotate'); if(k === 'r') this.setMode('scale');
                if(k === 'delete' || k === 'backspace') this.deleteSelection();
            }

            animate() {
                this.orbit.update();
                  if(!this.isGlobalView) {
                      this.scene.traverse(obj => {
                          if(obj.name === 'Label') {
                              const dist = obj.position.distanceTo(this.camera.position);
                              const scale = Math.max(1.5, dist / 15);
                              const base = obj.parent?.userData?.labelScale || CONFIG.defaultLabelScale;
                              obj.scale.set(scale * 2 * base, scale * base, 1);
                              obj.visible = this.labelsVisible && obj.parent?.userData.labelVisible !== false;
                          }
                      });
                  }
                  if(this.cablesVisible && this.cableMaterials.length) {
                      this.cableMaterials.forEach(mat => { mat.dashOffset -= 0.01; mat.needsUpdate = true; });
                  }
                  this.renderer.render(this.scene, this.camera);
              }
        }

        const app = new HotelArchitect();
        window.app = app; 
    </script>
</body>
</html>
